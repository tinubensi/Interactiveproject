"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OffsetLimitEndpointComponent = void 0;
const headerUtils_js_1 = require("../headerUtils.js");
const parallelQueryResult_js_1 = require("../parallelQueryResult.js");
const PartitionRangeUtils_js_1 = require("../PartitionRangeUtils.js");
/** @hidden */
class OffsetLimitEndpointComponent {
    executionContext;
    offset;
    limit;
    constructor(executionContext, offset, limit) {
        this.executionContext = executionContext;
        this.offset = offset;
        this.limit = limit;
    }
    hasMoreResults() {
        return (this.offset > 0 || this.limit > 0) && this.executionContext.hasMoreResults();
    }
    async fetchMore(diagnosticNode) {
        const aggregateHeaders = (0, headerUtils_js_1.getInitialHeader)();
        const buffer = [];
        const response = await this.executionContext.fetchMore(diagnosticNode);
        if (!response) {
            return { result: undefined, headers: aggregateHeaders };
        }
        (0, headerUtils_js_1.mergeHeaders)(aggregateHeaders, response.headers);
        if (response.result === undefined ||
            !Array.isArray(response.result.buffer) ||
            response.result.buffer.length === 0) {
            return { result: response.result, headers: response.headers };
        }
        const parallelResult = response.result;
        const dataToProcess = parallelResult.buffer;
        const partitionKeyRangeMap = parallelResult.partitionKeyRangeMap;
        const updatedContinuationRanges = parallelResult.updatedContinuationRanges;
        const orderByItems = parallelResult.orderByItems;
        const initialOffset = this.offset;
        const initialLimit = this.limit;
        const filteredOrderByItems = [];
        let itemIndex = 0;
        for (const item of dataToProcess) {
            if (this.offset > 0) {
                this.offset--;
                // Skip this item AND its corresponding orderByItems entry
            }
            else if (this.limit > 0) {
                buffer.push(item);
                // Include the corresponding orderByItems entry
                if (orderByItems && itemIndex < orderByItems.length) {
                    filteredOrderByItems.push(orderByItems[itemIndex]);
                }
                this.limit--;
            }
            itemIndex++;
        }
        // Process offset/limit logic and update partition key range map
        // Note: Pass initial offset/limit values (not current state) to calculateOffsetLimitForPartitionRanges
        // This function updates partition metadata while the loop above processes actual data items
        const updatedPartitionKeyRangeMap = (0, PartitionRangeUtils_js_1.calculateOffsetLimitForPartitionRanges)(partitionKeyRangeMap, initialOffset, initialLimit);
        // Return in the new structure format using the utility function
        const result = (0, parallelQueryResult_js_1.createParallelQueryResult)(buffer, updatedPartitionKeyRangeMap, updatedContinuationRanges, filteredOrderByItems.length > 0 ? filteredOrderByItems : undefined);
        return {
            result,
            headers: aggregateHeaders,
        };
    }
}
exports.OffsetLimitEndpointComponent = OffsetLimitEndpointComponent;
//# sourceMappingURL=OffsetLimitEndpointComponent.js.map