{"version":3,"file":"BaseContinuationTokenManager.js","sourceRoot":"","sources":["../../../../src/queryExecutionContext/ContinuationTokenManager/BaseContinuationTokenManager.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { QueryRangeMapping } from \"../queryRangeMapping.js\";\nimport {\n  parseBaseContinuationToken,\n  type QueryRangeWithContinuationToken,\n  type RangeBoundary,\n} from \"../../documents/ContinuationToken/CompositeQueryContinuationToken.js\";\nimport type {\n  PartitionRangeUpdate,\n  PartitionRangeUpdates,\n} from \"../../documents/ContinuationToken/PartitionRangeUpdate.js\";\nimport { PartitionRangeManager } from \"../PartitionRangeManager.js\";\nimport type { ParallelQueryResult } from \"../parallelQueryResult.js\";\n\n/**\n * Base abstract class for continuation token management.\n * Provides common functionality shared between parallel and ORDER BY query token managers.\n * @internal\n */\nexport abstract class BaseContinuationTokenManager {\n  private ranges: QueryRangeWithContinuationToken[] = [];\n  private readonly partitionRangeManager: PartitionRangeManager = new PartitionRangeManager();\n\n  constructor(initialContinuationToken?: string) {\n    if (initialContinuationToken) {\n      const token = parseBaseContinuationToken(initialContinuationToken);\n      if (token?.rangeMappings) {\n        this.ranges = token.rangeMappings;\n      }\n    }\n  }\n\n  /**\n   * Provides controlled access to partition range manager for subclasses.\n   * This is the only protected access point needed.\n   */\n  protected get partitionManager(): PartitionRangeManager {\n    return this.partitionRangeManager;\n  }\n\n  /**\n   * Provides controlled access to ranges for subclasses.\n   * Made protected to allow subclass range management.\n   */\n  protected get rangeList(): QueryRangeWithContinuationToken[] {\n    return this.ranges;\n  }\n\n  /**\n   * Gets the current continuation token for serialization.\n   * Returns undefined if no token exists or query is exhausted.\n   */\n  protected abstract getCurrentContinuationToken(): any;\n\n  /**\n   * Processes query results and generates continuation tokens for pagination.\n   * Handles response data processing, range management, and token generation.\n   *\n   * @param pageSize - Maximum number of items to return in this page\n   * @param isResponseEmpty - Whether the current response contains no data\n   * @param responseResult - Optional response data containing partition mappings and query-specific data\n   * @returns Object containing the end index for slicing results and optional continuation token for next page\n   */\n  public paginateResults(\n    pageSize: number,\n    isResponseEmpty: boolean,\n    responseResult?: ParallelQueryResult,\n  ): {\n    endIndex: number;\n    continuationToken?: string;\n  } {\n    // Process response data\n    if (responseResult) {\n      this.processResponseResult(responseResult);\n    }\n\n    this.removeExhaustedRangesFromRanges();\n    const result = this.processRangesForPagination(pageSize, isResponseEmpty);\n    const tokenString = this.generateContinuationTokenString();\n\n    // Clean up processed ranges\n    this.trimProcessedData(result.processedRanges, result.endIndex);\n\n    return {\n      endIndex: result.endIndex,\n      continuationToken: tokenString,\n    };\n  }\n\n  protected abstract processRangesForPagination(\n    pageSize: number,\n    isResponseEmpty: boolean,\n  ): {\n    endIndex: number;\n    processedRanges: string[];\n  };\n\n  protected abstract processQuerySpecificResponse(responseResult: ParallelQueryResult): void;\n  protected abstract performQuerySpecificDataTrim(\n    processedRanges: string[],\n    endIndex: number,\n  ): void;\n\n  /**\n   * Gets the serialization function for the specific continuation token type.\n   */\n  protected abstract getSerializationFunction(): (token: any) => string;\n\n  /**\n   * Generates continuation token string using the appropriate serialization function.\n   * This provides a common implementation that delegates to query-specific logic.\n   */\n  private generateContinuationTokenString(): string | undefined {\n    const token = this.getCurrentContinuationToken();\n    if (!token) {\n      return undefined;\n    }\n\n    const serializeFunction = this.getSerializationFunction();\n    return serializeFunction(token);\n  }\n\n  /**\n   * Cleans up processed data after a page has been returned.\n   * Handles both common and query-specific cleanup.\n   */\n  private trimProcessedData(processedRanges: string[], endIndex: number): void {\n    processedRanges.forEach((rangeId) => {\n      this.partitionRangeManager.removePartitionRangeMapping(rangeId);\n    });\n\n    // Delegate query-specific cleanup to subclass\n    this.performQuerySpecificDataTrim(processedRanges, endIndex);\n  }\n\n  private addPartitionKeyRangeMap(partitionKeyRangeMap: Map<string, QueryRangeMapping>): void {\n    this.partitionRangeManager.addPartitionKeyRangeMap(partitionKeyRangeMap);\n  }\n\n  /**\n   * Processes the entire response result and updates the continuation token manager state.\n   * This encapsulates all response handling logic in one place.\n   */\n  private processResponseResult(responseResult: ParallelQueryResult): void {\n    // Handle partition key range map\n    if (responseResult.partitionKeyRangeMap) {\n      this.addPartitionKeyRangeMap(responseResult.partitionKeyRangeMap);\n    }\n\n    // Handle partition range updates\n    if (responseResult.updatedContinuationRanges) {\n      this.handlePartitionRangeChanges(responseResult.updatedContinuationRanges);\n    }\n\n    this.processQuerySpecificResponse(responseResult);\n  }\n\n  private isPartitionExhausted(continuationToken: string | undefined): boolean {\n    return (\n      !continuationToken ||\n      continuationToken === \"\" ||\n      continuationToken === \"null\" ||\n      continuationToken.toLowerCase() === \"null\"\n    );\n  }\n\n  private removeExhaustedRangesFromRanges(): void {\n    if (!this.ranges || !Array.isArray(this.ranges)) {\n      return;\n    }\n    this.ranges = this.ranges.filter((mapping) => {\n      if (!mapping) {\n        return false;\n      }\n      const isExhausted = this.isPartitionExhausted(mapping.continuationToken);\n      return !isExhausted;\n    });\n  }\n\n  private handlePartitionRangeChanges(updatedContinuationRanges: PartitionRangeUpdates): void {\n    if (updatedContinuationRanges && Object.keys(updatedContinuationRanges).length === 0) {\n      return;\n    }\n    Object.entries(updatedContinuationRanges).forEach(([rangeKey, rangeChange]) => {\n      this.processRangeChange(rangeKey, rangeChange);\n    });\n  }\n\n  private processRangeChange(_rangeKey: string, rangeChange: PartitionRangeUpdate): void {\n    const { oldRange, newRanges, continuationToken } = rangeChange;\n    if (newRanges.length === 1) {\n      this.handleRangeMerge(oldRange, newRanges[0], continuationToken);\n    } else {\n      this.handleRangeSplit(oldRange, newRanges, continuationToken);\n    }\n  }\n\n  private handleRangeMerge(oldRange: any, newRange: any, continuationToken: string): void {\n    // Find existing range mapping to update in the common ranges array\n    const existingMappingIndex = this.ranges.findIndex(\n      (mapping) =>\n        mapping.queryRange.min === oldRange.min && mapping.queryRange.max === oldRange.max,\n    );\n\n    if (existingMappingIndex < 0) {\n      return;\n    }\n\n    // Update existing mapping with new range properties\n    const existingMapping = this.ranges[existingMappingIndex];\n\n    // Create new simplified QueryRange with updated boundaries\n    const updatedQueryRange: RangeBoundary = {\n      min: newRange.min,\n      max: newRange.max,\n    };\n\n    // Update the mapping\n    existingMapping.queryRange = updatedQueryRange;\n    existingMapping.continuationToken = continuationToken;\n  }\n\n  private handleRangeSplit(oldRange: any, newRanges: any[], continuationToken: string): void {\n    // Remove the old range mapping from the common ranges array\n    this.ranges = this.ranges.filter(\n      (mapping) =>\n        !(mapping.queryRange.min === oldRange.min && mapping.queryRange.max === oldRange.max),\n    );\n\n    // Add new range mappings for each split range\n    newRanges.forEach((newRange) => {\n      this.createNewRangeMapping(newRange, continuationToken);\n    });\n  }\n\n  private createNewRangeMapping(partitionKeyRange: any, continuationToken: string): void {\n    // Create new simplified QueryRange\n    const queryRange: RangeBoundary = {\n      min: partitionKeyRange.min,\n      max: partitionKeyRange.max,\n    };\n\n    // Create new QueryRangeWithContinuationToken\n    const newRangeWithToken: QueryRangeWithContinuationToken = {\n      queryRange: queryRange,\n      continuationToken: continuationToken,\n    };\n\n    this.ranges.push(newRangeWithToken);\n  }\n}\n"]}