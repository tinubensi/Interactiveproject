{"version":3,"file":"OrderByQueryRangeStrategy.js","sourceRoot":"","sources":["../../../../src/queryExecutionContext/queryFilteringStrategy/OrderByQueryRangeStrategy.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { PartitionKeyRange } from \"../../index.js\";\nimport type {\n  TargetPartitionRangeStrategy,\n  PartitionRangeFilterResult,\n} from \"./TargetPartitionRangeStrategy.js\";\nimport type { PartitionRangeWithContinuationToken } from \"./TargetPartitionRangeManager.js\";\n\n/**\n * Strategy for filtering partition ranges in ORDER BY query execution context\n * Supports resuming from continuation tokens with proper range-token pair management\n * @hidden\n */\nexport class OrderByQueryRangeStrategy implements TargetPartitionRangeStrategy {\n  getStrategyType(): string {\n    return \"OrderByQuery\";\n  }\n\n  filterPartitionRanges(\n    targetRanges: PartitionKeyRange[],\n    continuationRanges?: PartitionRangeWithContinuationToken[],\n    queryInfo?: Record<string, unknown>,\n  ): PartitionRangeFilterResult {\n    if (\n      !targetRanges ||\n      targetRanges.length === 0 ||\n      !continuationRanges ||\n      continuationRanges.length === 0\n    ) {\n      return {\n        rangeTokenPairs: [],\n      };\n    }\n\n    if (\n      !queryInfo?.orderByItems ||\n      !Array.isArray(queryInfo.orderByItems) ||\n      queryInfo.orderByItems.length === 0\n    ) {\n      throw new Error(\n        \"Unable to resume ORDER BY query from continuation token. orderByItems is required for ORDER BY queries.\",\n      );\n    }\n\n    const result: PartitionRangeFilterResult = {\n      rangeTokenPairs: [],\n    };\n    let filteredRanges: PartitionKeyRange[] = [];\n    let resumeRangeFound = false;\n\n    if (continuationRanges && continuationRanges.length > 0) {\n      resumeRangeFound = true;\n      // Find the range to resume from based on the composite token\n      const targetRangeMapping = continuationRanges[continuationRanges.length - 1].range;\n      // It is assumed that range mapping array is going to contain only range\n      const targetRange: PartitionKeyRange = targetRangeMapping;\n\n      const targetContinuationToken =\n        continuationRanges[continuationRanges.length - 1].continuationToken;\n\n      const leftRanges = targetRanges.filter((mapping) =>\n        this.isRangeBeforeAnother(mapping.maxExclusive, targetRangeMapping.minInclusive),\n      );\n\n      const orderByItems = queryInfo.orderByItems;\n\n      // Create filtering condition for left ranges based on ORDER BY items and sort orders\n      const leftFilter = this.createRangeFilterCondition(orderByItems, queryInfo, \"left\");\n\n      const rightRanges = targetRanges.filter((mapping) =>\n        this.isRangeAfterAnother(mapping.minInclusive, targetRangeMapping.maxExclusive),\n      );\n\n      // Create filtering condition for right ranges based on ORDER BY items and sort orders\n      const rightFilter = this.createRangeFilterCondition(orderByItems, queryInfo, \"right\");\n\n      // Apply filtering logic for left ranges\n      if (leftRanges.length > 0) {\n        leftRanges.forEach((range) => {\n          result.rangeTokenPairs.push({\n            range: range,\n            continuationToken: undefined,\n            filteringCondition: leftFilter,\n          });\n        });\n      }\n\n      result.rangeTokenPairs.push({\n        range: targetRange,\n        continuationToken: targetContinuationToken,\n        filteringCondition: rightFilter,\n      });\n\n      // Apply filtering logic for right ranges\n      if (rightRanges.length > 0) {\n        rightRanges.forEach((range) => {\n          result.rangeTokenPairs.push({\n            range: range,\n            continuationToken: undefined,\n            filteringCondition: rightFilter,\n          });\n        });\n      }\n    }\n\n    // If we couldn't find a specific resume point, include all ranges\n    // This can happen with certain types of ORDER BY continuation tokens\n    if (!resumeRangeFound) {\n      filteredRanges = [...targetRanges];\n      filteredRanges.forEach((range) => {\n        result.rangeTokenPairs.push({\n          range: range,\n          continuationToken: undefined,\n          filteringCondition: undefined,\n        });\n      });\n    }\n    return result;\n  }\n\n  /**\n   * Creates a filter condition for ranges based on ORDER BY items and sort orders\n   * This filter ensures that ranges only return documents based on their position relative to the continuation point\n   * @param orderByItems - Array of order by items from the continuation token\n   * @param queryInfo - Query information containing sort orders and other metadata\n   * @param rangePosition - Whether this is for \"left\" or \"right\" ranges relative to continuation point\n   * @returns SQL filter condition string for the specified range position\n   */\n  private createRangeFilterCondition(\n    orderByItems: any[],\n    queryInfo: Record<string, unknown> | undefined,\n    rangePosition: \"left\" | \"right\",\n  ): string {\n    // Extract sort orders from query info\n    let sortOrders: string[];\n    try {\n      sortOrders = this.extractSortOrders(queryInfo);\n    } catch (error) {\n      // If we can't extract sort orders, we cannot create reliable filter conditions\n      throw new Error(\n        `Unable to resume ORDER BY query from continuation token. The ORDER BY sort direction configuration ` +\n          `in the query plan is invalid or missing. This may indicate a client version mismatch or corrupted continuation token. ` +\n          `Please retry the query without a continuation token. Original error: ${error}`,\n      );\n    }\n\n    // Extract orderByExpressions from nested structure\n    let orderByExpressions: any[] | undefined;\n    if (\n      queryInfo &&\n      queryInfo.queryInfo &&\n      typeof queryInfo.queryInfo === \"object\" &&\n      (queryInfo.queryInfo as any).queryInfo &&\n      (queryInfo.queryInfo as any).queryInfo.orderByExpressions &&\n      Array.isArray((queryInfo.queryInfo as any).queryInfo.orderByExpressions)\n    ) {\n      orderByExpressions = (queryInfo.queryInfo as any).queryInfo.orderByExpressions;\n    }\n\n    if (!orderByExpressions || !Array.isArray(orderByExpressions)) {\n      throw new Error(\n        \"Unable to resume ORDER BY query from continuation token. The ORDER BY field configuration \" +\n          \"in the query plan is invalid or missing. This may indicate a client version mismatch or corrupted continuation token. \" +\n          \"Please retry the query without a continuation token.\",\n      );\n    }\n\n    const filterConditions: string[] = [];\n\n    // Process each order by item to create filter conditions\n    for (let i = 0; i < orderByItems.length && i < sortOrders.length; i++) {\n      const orderByItem = orderByItems[i];\n      const sortOrder = sortOrders[i];\n\n      if (!orderByItem || orderByItem.item === undefined) {\n        continue;\n      }\n\n      try {\n        // Determine the field path from ORDER BY expressions in query plan\n        const fieldPath = this.extractFieldPath(queryInfo, i);\n\n        // Create the comparison condition based on sort order and range position\n        const condition = this.createComparisonCondition(\n          fieldPath,\n          orderByItem.item,\n          sortOrder,\n          rangePosition,\n        );\n\n        if (condition) {\n          filterConditions.push(condition);\n        }\n      } catch (error) {\n        // If we can't extract field path for ORDER BY expressions, we cannot safely resume from continuation token\n        // This would lead to incorrect query results, so we must fail the entire request\n        throw new Error(\n          `Unable to resume ORDER BY query from continuation token. The ORDER BY field configuration ` +\n            `in the query plan is invalid or incompatible with the continuation token format. ` +\n            `This may indicate a client version mismatch or corrupted continuation token. ` +\n            `Please retry the query without a continuation token. Original error: ${error}`,\n        );\n      }\n    }\n\n    // Combine multiple conditions with AND for multi-field ORDER BY\n    const combinedFilter = filterConditions.length > 0 ? `(${filterConditions.join(\" AND \")})` : \"\";\n    return combinedFilter;\n  }\n\n  /**\n   * Extracts sort orders from query info\n   * @throws Error if sort order information is missing or invalid\n   */\n  private extractSortOrders(queryInfo?: Record<string, unknown>): string[] {\n    if (!queryInfo) {\n      throw new Error(\"Query information is required to determine ORDER BY sort directions\");\n    }\n\n    // Extract orderBy from the nested structure: queryInfo.queryInfo.queryInfo.orderBy\n    let orderBy: any[] | undefined;\n\n    if (\n      queryInfo.queryInfo &&\n      typeof queryInfo.queryInfo === \"object\" &&\n      (queryInfo.queryInfo as any).queryInfo &&\n      typeof (queryInfo.queryInfo as any).queryInfo === \"object\" &&\n      (queryInfo.queryInfo as any).queryInfo.orderBy &&\n      Array.isArray((queryInfo.queryInfo as any).queryInfo.orderBy)\n    ) {\n      orderBy = (queryInfo.queryInfo as any).queryInfo.orderBy;\n    }\n\n    if (!orderBy) {\n      throw new Error(\"ORDER BY sort direction information is missing from query plan\");\n    }\n\n    return orderBy.map((order, index) => {\n      if (typeof order === \"string\") {\n        return order;\n      }\n      // Handle object format if needed\n      if (order && typeof order === \"object\") {\n        const sortOrder =\n          (order as any).direction || (order as any).order || (order as any).sortOrder;\n        if (sortOrder) {\n          return sortOrder;\n        }\n      }\n      throw new Error(\n        `ORDER BY sort direction at position ${index + 1} has an invalid format in the query plan`,\n      );\n    });\n  }\n\n  /**\n   * Extracts field path from ORDER BY expressions in query plan\n   * @throws Error if orderByExpressions are not found or index is out of bounds or expression format is invalid\n   */\n  private extractFieldPath(queryInfo: Record<string, unknown> | undefined, index: number): string {\n    // Try multiple paths to find orderByExpressions due to nested structure\n    let orderByExpressions: any[] | undefined;\n\n    if (queryInfo) {\n      // Direct path\n      if (queryInfo.orderByExpressions && Array.isArray(queryInfo.orderByExpressions)) {\n        orderByExpressions = queryInfo.orderByExpressions;\n      }\n      // Nested path: queryInfo.queryInfo.queryInfo.orderByExpressions\n      else if (\n        queryInfo.queryInfo &&\n        typeof queryInfo.queryInfo === \"object\" &&\n        (queryInfo.queryInfo as any).queryInfo &&\n        (queryInfo.queryInfo as any).queryInfo.orderByExpressions &&\n        Array.isArray((queryInfo.queryInfo as any).queryInfo.orderByExpressions)\n      ) {\n        orderByExpressions = (queryInfo.queryInfo as any).queryInfo.orderByExpressions;\n      }\n    }\n\n    if (!orderByExpressions) {\n      throw new Error(\"ORDER BY field information is missing from query plan\");\n    }\n\n    if (index >= orderByExpressions.length) {\n      throw new Error(\n        `ORDER BY field configuration mismatch: expected at least ${index + 1} fields but found ${orderByExpressions.length}`,\n      );\n    }\n\n    const expression = orderByExpressions[index];\n\n    // Handle different formats of ORDER BY expressions\n    if (typeof expression === \"string\") {\n      // Simple string expression like \"c.id\" or \"_FullTextScore(...)\"\n      return expression;\n    }\n\n    if (expression && typeof expression === \"object\") {\n      // Object format like { expression: \"c.id\", type: \"PropertyRef\" }\n      if (expression.expression) {\n        return expression.expression;\n      }\n      if (expression.path) {\n        return expression.path.replace(/^\\//, \"\"); // Remove leading slash\n      }\n      if (expression.field) {\n        return expression.field;\n      }\n    }\n\n    throw new Error(\n      `ORDER BY field at position ${index + 1} has an unrecognized format in the query plan`,\n    );\n  }\n\n  /**\n   * Creates a comparison condition based on the field, value, sort order, and range position\n   */\n  private createComparisonCondition(\n    fieldPath: string,\n    value: any,\n    sortOrder: string,\n    rangePosition: \"left\" | \"right\",\n  ): string {\n    const isDescending =\n      sortOrder.toLowerCase() === \"descending\" || sortOrder.toLowerCase() === \"desc\";\n\n    // For left ranges (ranges that come before the target):\n    // - In ascending order: field > value (left ranges should seek for larger values)\n    // - In descending order: field < value (left ranges should seek for smaller values)\n\n    // For right ranges (ranges that come after the target):\n    // - In ascending order: field >= value (right ranges have larger values)\n    // - In descending order: field <= value (right ranges have smaller values in desc order)\n\n    let operator: string;\n\n    if (rangePosition === \"left\") {\n      operator = isDescending ? \"<\" : \">\";\n    } else {\n      // right\n      operator = isDescending ? \"<=\" : \">=\";\n    }\n\n    // Format the value based on its type\n    const formattedValue = this.formatValueForSQL(value);\n\n    // Create the condition with proper field reference\n    const condition = `${fieldPath} ${operator} ${formattedValue}`;\n    return condition;\n  }\n\n  /**\n   * Formats a value for use in SQL condition\n   */\n  private formatValueForSQL(value: any): string {\n    if (value === null || value === undefined) {\n      return \"null\";\n    }\n\n    const valueType = typeof value;\n\n    switch (valueType) {\n      case \"string\":\n        // Escape single quotes and wrap in quotes\n        return `'${value.toString().replace(/'/g, \"''\")}'`;\n      case \"number\":\n      case \"bigint\":\n        return value.toString();\n      case \"boolean\":\n        return value ? \"true\" : \"false\";\n      default:\n        // For objects and arrays, convert to JSON string\n        if (typeof value === \"object\") {\n          return `'${JSON.stringify(value).replace(/'/g, \"''\")}'`;\n        }\n        return `'${value.toString().replace(/'/g, \"''\")}'`;\n    }\n  }\n\n  /**\n   * Compares partition key range boundaries with proper handling for inclusive/exclusive semantics\n   * @param boundary1 - First boundary to compare\n   * @param boundary2 - Second boundary to compare\n   * @returns negative if boundary1 is less than boundary2, positive if boundary1 is greater than boundary2, 0 if equal\n   */\n  private comparePartitionKeyBoundaries(boundary1: string, boundary2: string): number {\n    // Handle empty string cases (empty string represents the minimum boundary)\n    if (boundary1 === \"\" && boundary2 === \"\") return 0;\n    if (boundary1 === \"\") return -1; // \"\" < \"AA\"\n    if (boundary2 === \"\") return 1; // \"AA\" > \"\"\n\n    // Use standard lexicographic comparison for non-empty boundaries\n    return boundary1.localeCompare(boundary2);\n  }\n\n  private isRangeBeforeAnother(range1MaxExclusive: string, range2MinInclusive: string): boolean {\n    // Since range1.maxExclusive is NOT part of range1, and range2.minInclusive IS part of range2,\n    // range1 comes before range2 if range1.maxExclusive <= range2.minInclusive\n    return this.comparePartitionKeyBoundaries(range1MaxExclusive, range2MinInclusive) <= 0;\n  }\n\n  private isRangeAfterAnother(range1MinInclusive: string, range2MaxExclusive: string): boolean {\n    // Since range2.maxExclusive is NOT part of range2, and range1.minInclusive IS part of range1,\n    // range1 comes after range2 if range1.minInclusive >= range2.maxExclusive\n    return this.comparePartitionKeyBoundaries(range1MinInclusive, range2MaxExclusive) >= 0;\n  }\n}\n"]}