{"version":3,"file":"NonStreamingOrderByDistinctEndpointComponent.js","sourceRoot":"","sources":["../../../../src/queryExecutionContext/EndpointComponent/NonStreamingOrderByDistinctEndpointComponent.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { QueryInfo, Response } from \"../../request/index.js\";\nimport type { ExecutionContext } from \"../ExecutionContext.js\";\nimport { getInitialHeader } from \"../headerUtils.js\";\nimport type { DiagnosticNodeInternal } from \"../../diagnostics/DiagnosticNodeInternal.js\";\nimport { hashObject } from \"../../utils/hashObject.js\";\nimport type { NonStreamingOrderByResult } from \"../nonStreamingOrderByResult.js\";\nimport { FixedSizePriorityQueue } from \"../../utils/fixedSizePriorityQueue.js\";\nimport { NonStreamingOrderByMap } from \"../../utils/nonStreamingOrderByMap.js\";\nimport { OrderByComparator } from \"../orderByComparator.js\";\nimport type { ParallelQueryResult } from \"../parallelQueryResult.js\";\nimport { createParallelQueryResult } from \"../parallelQueryResult.js\";\n\n/**\n * @hidden\n * Represents an endpoint in handling an non-streaming order by distinct query.\n */\nexport class NonStreamingOrderByDistinctEndpointComponent implements ExecutionContext {\n  /**\n   * A Map that holds the distinct values of the items before storing in priority queue.\n   */\n  private aggregateMap: NonStreamingOrderByMap<NonStreamingOrderByResult>;\n  /**\n   * A priority queue to compute the final sorted results.\n   */\n  private nonStreamingOrderByPQ: FixedSizePriorityQueue<NonStreamingOrderByResult>;\n  /**\n   * Array to store the final sorted results.\n   */\n  private finalResultArray: NonStreamingOrderByResult[];\n\n  private sortOrders: string[];\n  /**\n   * Flag to determine if all results are fetched from backend and results can be returned.\n   */\n  private isCompleted: boolean = false;\n\n  constructor(\n    private executionContext: ExecutionContext,\n    private queryInfo: QueryInfo,\n    private priorityQueueBufferSize: number,\n    private emitRawOrderByPayload: boolean = false,\n  ) {\n    this.sortOrders = this.queryInfo.orderBy;\n    const comparator = new OrderByComparator(this.sortOrders);\n    this.aggregateMap = new NonStreamingOrderByMap<NonStreamingOrderByResult>(\n      (a: NonStreamingOrderByResult, b: NonStreamingOrderByResult) => {\n        return comparator.compareItems(a, b);\n      },\n    );\n    this.nonStreamingOrderByPQ = new FixedSizePriorityQueue<NonStreamingOrderByResult>(\n      (a: NonStreamingOrderByResult, b: NonStreamingOrderByResult) => {\n        return comparator.compareItems(b, a);\n      },\n      this.priorityQueueBufferSize,\n    );\n  }\n\n  /**\n   * Build final sorted result array from which responses will be served.\n   */\n  private async buildFinalResultArray(): Promise<void> {\n    // Fetch all distinct values from the map and store in priority queue.\n    const allValues = this.aggregateMap.getAllValuesAndReset();\n    for (const value of allValues) {\n      this.nonStreamingOrderByPQ.enqueue(value);\n    }\n\n    // Compute the final result array size based on offset and limit.\n    const offSet = this.queryInfo.offset ? this.queryInfo.offset : 0;\n    const queueSize = this.nonStreamingOrderByPQ.size();\n    const finalArraySize = queueSize - offSet;\n\n    if (finalArraySize <= 0) {\n      this.finalResultArray = [];\n    } else {\n      this.finalResultArray = new Array(finalArraySize);\n      // Only keep the final result array size number of items in the final result array and discard the rest.\n      for (let count = finalArraySize - 1; count >= 0; count--) {\n        if (this.emitRawOrderByPayload) {\n          this.finalResultArray[count] = this.nonStreamingOrderByPQ.dequeue();\n        } else {\n          this.finalResultArray[count] = this.nonStreamingOrderByPQ.dequeue()?.payload;\n        }\n      }\n    }\n  }\n\n  public hasMoreResults(): boolean {\n    if (this.priorityQueueBufferSize === 0) return false;\n    return this.executionContext.hasMoreResults();\n  }\n\n  public async fetchMore(diagnosticNode?: DiagnosticNodeInternal): Promise<Response<any>> {\n    if (this.isCompleted) {\n      return {\n        result: undefined,\n        headers: getInitialHeader(),\n      };\n    }\n    let resHeaders = getInitialHeader();\n    // if size is 0, just return undefined to signal to more results. Valid if query is TOP 0 or LIMIT 0\n    if (this.priorityQueueBufferSize <= 0) {\n      return {\n        result: undefined,\n        headers: resHeaders,\n      };\n    }\n\n    // If there are more results in backend, keep filling map.\n    if (this.executionContext.hasMoreResults()) {\n      // Grab the next result\n      const response = await this.executionContext.fetchMore(diagnosticNode);\n\n      if (!response) {\n        this.isCompleted = true;\n        if (this.aggregateMap.size() > 0) {\n          await this.buildFinalResultArray();\n          const result = createParallelQueryResult(this.finalResultArray, new Map(), {}, undefined);\n\n          return {\n            result,\n            headers: resHeaders,\n          };\n        }\n        return { result: undefined, headers: resHeaders };\n      }\n\n      if (\n        response.result === undefined ||\n        !Array.isArray(response.result.buffer) ||\n        response.result.buffer.length === 0\n      ) {\n        this.isCompleted = true;\n        if (this.aggregateMap.size() > 0) {\n          await this.buildFinalResultArray();\n          const result = createParallelQueryResult(this.finalResultArray, new Map(), {}, undefined);\n\n          return {\n            result,\n            headers: response.headers,\n          };\n        }\n        return { result: undefined, headers: response.headers };\n      }\n      resHeaders = response.headers;\n\n      const parallelResult = response.result as ParallelQueryResult;\n      const dataToProcess: NonStreamingOrderByResult[] =\n        parallelResult.buffer as NonStreamingOrderByResult[];\n\n      for (const item of dataToProcess) {\n        if (item) {\n          const key = await hashObject(item?.payload);\n          this.aggregateMap.set(key, item);\n        }\n      }\n\n      // return [] to signal that there are more results to fetch.\n      if (this.executionContext.hasMoreResults()) {\n        const result = createParallelQueryResult(\n          [], // empty buffer\n          new Map(),\n          undefined,\n          undefined,\n        );\n\n        return {\n          result,\n          headers: resHeaders,\n        };\n      }\n    }\n\n    // If all results are fetched from backend, prepare final results\n    if (!this.executionContext.hasMoreResults() && !this.isCompleted) {\n      this.isCompleted = true;\n      await this.buildFinalResultArray();\n      const result = createParallelQueryResult(this.finalResultArray, new Map());\n\n      return {\n        result,\n        headers: resHeaders,\n      };\n    }\n    // Signal that there are no more results.\n    const result = createParallelQueryResult([], new Map());\n\n    return {\n      result,\n      headers: resHeaders,\n    };\n  }\n}\n"]}