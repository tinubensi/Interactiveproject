"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParallelQueryContinuationTokenManager = void 0;
const BaseContinuationTokenManager_js_1 = require("./BaseContinuationTokenManager.js");
const CompositeQueryContinuationToken_js_1 = require("../../documents/ContinuationToken/CompositeQueryContinuationToken.js");
/**
 * Manages continuation tokens for parallel queries using multi-range aggregation.
 * Uses CompositeQueryContinuationToken for range tracking across multiple partitions.
 * @internal
 */
class ParallelQueryContinuationTokenManager extends BaseContinuationTokenManager_js_1.BaseContinuationTokenManager {
    continuationToken;
    collectionLink;
    constructor(collectionLink, initialContinuationToken) {
        super(initialContinuationToken);
        this.collectionLink = collectionLink;
        if (initialContinuationToken) {
            this.continuationToken = (0, CompositeQueryContinuationToken_js_1.parseCompositeQueryContinuationToken)(initialContinuationToken);
        }
    }
    processRangesForPagination(pageSize, _isResponseEmpty) {
        const result = this.partitionManager.processParallelRanges(pageSize);
        if (!result || !result.processedRangeMappings || result.processedRangeMappings.length === 0) {
            return { endIndex: 0, processedRanges: [] };
        }
        const rangeMappings = result.processedRangeMappings.map((mapping) => (0, CompositeQueryContinuationToken_js_1.convertRangeMappingToQueryRange)(mapping));
        if (!this.continuationToken) {
            this.continuationToken = (0, CompositeQueryContinuationToken_js_1.createCompositeQueryContinuationToken)(this.collectionLink, rangeMappings);
        }
        else {
            this.updateExistingCompositeContinuationToken(rangeMappings);
        }
        if (result.lastPartitionBeforeCutoff && result.lastPartitionBeforeCutoff.mapping) {
            this.continuationToken.offset = result.lastPartitionBeforeCutoff.mapping.offset;
            this.continuationToken.limit = result.lastPartitionBeforeCutoff.mapping.limit;
        }
        return { endIndex: result.endIndex, processedRanges: result.processedRanges };
    }
    getCurrentContinuationToken() {
        return this.continuationToken;
    }
    getSerializationFunction() {
        return CompositeQueryContinuationToken_js_1.serializeCompositeToken;
    }
    processQuerySpecificResponse(_responseResult) {
        // Parallel queries don't need additional response processing
    }
    performQuerySpecificDataTrim(_processedRanges, _endIndex) {
        // Parallel queries don't need additional cleanup
    }
    updateExistingCompositeContinuationToken(rangeMappings) {
        for (const newRange of rangeMappings) {
            // Check if this range already exists in the token
            const existingRangeIndex = this.continuationToken.rangeMappings.findIndex((existingRange) => existingRange.queryRange.min === newRange.queryRange.min &&
                existingRange.queryRange.max === newRange.queryRange.max);
            if (existingRangeIndex >= 0) {
                // Range exists - update the continuation token
                this.continuationToken.rangeMappings[existingRangeIndex] = newRange;
            }
            else {
                // New range - add to the rangeMappings array
                this.continuationToken.rangeMappings.push(newRange);
            }
        }
    }
}
exports.ParallelQueryContinuationTokenManager = ParallelQueryContinuationTokenManager;
//# sourceMappingURL=ParallelQueryContinuationTokenManager.js.map