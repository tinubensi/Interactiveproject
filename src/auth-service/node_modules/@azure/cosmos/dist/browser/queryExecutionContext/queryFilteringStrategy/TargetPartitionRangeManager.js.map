{"version":3,"file":"TargetPartitionRangeManager.js","sourceRoot":"","sources":["../../../../src/queryExecutionContext/queryFilteringStrategy/TargetPartitionRangeManager.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAOlC,OAAO,EAAE,0BAA0B,EAAE,MAAM,iCAAiC,CAAC;AAC7E,OAAO,EAAE,yBAAyB,EAAE,MAAM,gCAAgC,CAAC;AAY3E;;;GAGG;AACH,MAAM,CAAN,IAAY,yBAGX;AAHD,WAAY,yBAAyB;IACnC,kDAAqB,CAAA;IACrB,gDAAmB,CAAA;AACrB,CAAC,EAHW,yBAAyB,KAAzB,yBAAyB,QAGpC;AAuBD;;;;GAIG;AACH,MAAM,OAAO,2BAA2B;IAC9B,QAAQ,CAA+B;IACvC,MAAM,CAAoC;IAElD,YAAY,MAAyC;QACnD,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;IAC9C,CAAC;IAED;;OAEG;IACK,cAAc,CAAC,MAAyC;QAC9D,kCAAkC;QAClC,IAAI,MAAM,CAAC,cAAc,EAAE,CAAC;YAC1B,OAAO,MAAM,CAAC,cAAc,CAAC;QAC/B,CAAC;QAED,8CAA8C;QAC9C,QAAQ,MAAM,CAAC,SAAS,EAAE,CAAC;YACzB,KAAK,yBAAyB,CAAC,QAAQ;gBACrC,OAAO,IAAI,0BAA0B,EAAE,CAAC;YAE1C,KAAK,yBAAyB,CAAC,OAAO;gBACpC,OAAO,IAAI,yBAAyB,EAAE,CAAC;YAEzC;gBACE,MAAM,IAAI,KAAK,CAAC,6CAA6C,MAAM,CAAC,SAAS,EAAE,CAAC,CAAC;QACrF,CAAC;IACH,CAAC;IAED;;;;;;OAMG;IACI,qBAAqB,CAC1B,YAAiC,EACjC,eAAuD,EACvD,mBAA6C;QAE7C,kBAAkB;QAClB,IAAI,CAAC,YAAY,IAAI,YAAY,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAC/C,OAAO,EAAE,eAAe,EAAE,EAAE,EAAE,CAAC;QACjC,CAAC;QAED,+EAA+E;QAC/E,MAAM,eAAe,GAAG,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE,GAAG,mBAAmB,EAAE,CAAC;QAE7E,MAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,qBAAqB,CAChD,YAAY,EACZ,eAAe,EACf,eAAe,CAChB,CAAC;QACF,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;OAEG;IACI,eAAe;QACpB,OAAO,IAAI,CAAC,QAAQ,CAAC,eAAe,EAAE,CAAC;IACzC,CAAC;IAED;;OAEG;IACI,cAAc,CAAC,SAA4C;QAChE,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC;QACxB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,CAAC;IACjD,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,sBAAsB,CAClC,SAAkC;QAElC,OAAO,IAAI,2BAA2B,CAAC;YACrC,SAAS,EAAE,yBAAyB,CAAC,QAAQ;YAC7C,SAAS;SACV,CAAC,CAAC;IACL,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,qBAAqB,CACjC,SAAkC;QAElC,OAAO,IAAI,2BAA2B,CAAC;YACrC,SAAS,EAAE,yBAAyB,CAAC,OAAO;YAC5C,SAAS;SACV,CAAC,CAAC;IACL,CAAC;CACF","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { PartitionKeyRange } from \"../../index.js\";\nimport type {\n  TargetPartitionRangeStrategy,\n  PartitionRangeFilterResult,\n} from \"./TargetPartitionRangeStrategy.js\";\nimport { ParallelQueryRangeStrategy } from \"./ParallelQueryRangeStrategy.js\";\nimport { OrderByQueryRangeStrategy } from \"./OrderByQueryRangeStrategy.js\";\n\n/**\n * Interface representing a partition key range with its associated continuation token and filtering condition\n * @hidden\n */\nexport interface PartitionRangeWithContinuationToken {\n  range: PartitionKeyRange;\n  continuationToken?: string;\n  filteringCondition?: string;\n}\n\n/**\n * Query execution context types\n * @hidden\n */\nexport enum QueryExecutionContextType {\n  Parallel = \"Parallel\",\n  OrderBy = \"OrderBy\",\n}\n\n/**\n * Configuration for the Target Partition Range Manager\n * @hidden\n */\nexport interface TargetPartitionRangeManagerConfig {\n  /**\n   * The type of query execution context\n   */\n  queryType: QueryExecutionContextType;\n\n  /**\n   * Additional query information that might be needed for filtering decisions\n   */\n  queryInfo: Record<string, unknown>;\n\n  /**\n   * Custom strategy instance (optional, will use default strategies if not provided)\n   */\n  customStrategy?: TargetPartitionRangeStrategy;\n}\n\n/**\n * Manager class responsible for filtering target partition ranges based on query type and continuation tokens.\n * Uses the Strategy pattern to provide different filtering logic for different query types.\n * @hidden\n */\nexport class TargetPartitionRangeManager {\n  private strategy: TargetPartitionRangeStrategy;\n  private config: TargetPartitionRangeManagerConfig;\n\n  constructor(config: TargetPartitionRangeManagerConfig) {\n    this.config = config;\n    this.strategy = this.createStrategy(config);\n  }\n\n  /**\n   * Creates the appropriate strategy based on configuration\n   */\n  private createStrategy(config: TargetPartitionRangeManagerConfig): TargetPartitionRangeStrategy {\n    // Use custom strategy if provided\n    if (config.customStrategy) {\n      return config.customStrategy;\n    }\n\n    // Create default strategy based on query type\n    switch (config.queryType) {\n      case QueryExecutionContextType.Parallel:\n        return new ParallelQueryRangeStrategy();\n\n      case QueryExecutionContextType.OrderBy:\n        return new OrderByQueryRangeStrategy();\n\n      default:\n        throw new Error(`Unsupported query execution context type: ${config.queryType}`);\n    }\n  }\n\n  /**\n   * Filters target partition ranges based on range-token pairs from partition split/merge detection\n   * @param targetRanges - All available target partition ranges (fallback if no range-token pairs)\n   * @param rangeTokenPairs - Pre-processed range-token pairs after split/merge detection\n   * @param additionalQueryInfo - Additional query information to merge with existing queryInfo\n   * @returns Filtered partition ranges and metadata\n   */\n  public filterPartitionRanges(\n    targetRanges: PartitionKeyRange[],\n    rangeTokenPairs?: PartitionRangeWithContinuationToken[],\n    additionalQueryInfo?: Record<string, unknown>,\n  ): PartitionRangeFilterResult {\n    // Validate inputs\n    if (!targetRanges || targetRanges.length === 0) {\n      return { rangeTokenPairs: [] };\n    }\n\n    // Merge base queryInfo with additional queryInfo (additional takes precedence)\n    const mergedQueryInfo = { ...this.config.queryInfo, ...additionalQueryInfo };\n\n    const result = this.strategy.filterPartitionRanges(\n      targetRanges,\n      rangeTokenPairs,\n      mergedQueryInfo,\n    );\n    return result;\n  }\n\n  /**\n   * Gets the current strategy type\n   */\n  public getStrategyType(): string {\n    return this.strategy.getStrategyType();\n  }\n\n  /**\n   * Updates the strategy (useful for switching between query types)\n   */\n  public updateStrategy(newConfig: TargetPartitionRangeManagerConfig): void {\n    this.config = newConfig;\n    this.strategy = this.createStrategy(newConfig);\n  }\n\n  /**\n   * Static factory method to create a manager for parallel queries\n   */\n  public static createForParallelQuery(\n    queryInfo: Record<string, unknown>,\n  ): TargetPartitionRangeManager {\n    return new TargetPartitionRangeManager({\n      queryType: QueryExecutionContextType.Parallel,\n      queryInfo,\n    });\n  }\n\n  /**\n   * Static factory method to create a manager for ORDER BY queries\n   */\n  public static createForOrderByQuery(\n    queryInfo: Record<string, unknown>,\n  ): TargetPartitionRangeManager {\n    return new TargetPartitionRangeManager({\n      queryType: QueryExecutionContextType.OrderBy,\n      queryInfo,\n    });\n  }\n}\n"]}