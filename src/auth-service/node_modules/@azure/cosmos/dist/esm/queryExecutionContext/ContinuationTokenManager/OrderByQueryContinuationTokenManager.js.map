{"version":3,"file":"OrderByQueryContinuationTokenManager.js","sourceRoot":"","sources":["../../../../src/queryExecutionContext/ContinuationTokenManager/OrderByQueryContinuationTokenManager.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { BaseContinuationTokenManager } from \"./BaseContinuationTokenManager.js\";\nimport type { ParallelQueryResult, OrderByItemWithRid } from \"../parallelQueryResult.js\";\nimport type { OrderByQueryContinuationToken } from \"../../documents/ContinuationToken/OrderByQueryContinuationToken.js\";\nimport {\n  createOrderByQueryContinuationToken,\n  parseOrderByQueryContinuationToken,\n  serializeOrderByQueryContinuationToken,\n} from \"../../documents/ContinuationToken/OrderByQueryContinuationToken.js\";\nimport { convertRangeMappingToQueryRange } from \"../../documents/ContinuationToken/CompositeQueryContinuationToken.js\";\n\n/**\n * Manages continuation tokens for ORDER BY queries using single-range sequential processing.\n * Uses OrderByQueryContinuationToken for tracking ORDER BY items and skip counts.\n * @internal\n */\nexport class OrderByQueryContinuationTokenManager extends BaseContinuationTokenManager {\n  private continuationToken: OrderByQueryContinuationToken | undefined;\n  private readonly orderByItemsArray: OrderByItemWithRid[];\n  private readonly collectionLink: string;\n\n  constructor(collectionLink: string, initialContinuationToken?: string) {\n    super(initialContinuationToken);\n    this.collectionLink = collectionLink;\n    this.orderByItemsArray = [];\n    if (initialContinuationToken) {\n      this.continuationToken = parseOrderByQueryContinuationToken(initialContinuationToken);\n    }\n  }\n\n  protected processQuerySpecificResponse(responseResult: ParallelQueryResult): void {\n    // Clear existing items and add new ones without reassigning the array reference\n    this.orderByItemsArray.length = 0;\n    if (responseResult.orderByItems) {\n      this.orderByItemsArray.push(...responseResult.orderByItems);\n    }\n  }\n\n  protected performQuerySpecificDataTrim(_processedRanges: string[], endIndex: number): void {\n    this.sliceOrderByItemsArray(endIndex);\n  }\n\n  private sliceOrderByItemsArray(endIndex: number): void {\n    if (endIndex === 0 || endIndex >= this.orderByItemsArray.length) {\n      // Clear the array without reassigning\n      this.orderByItemsArray.length = 0;\n    } else {\n      // Remove items from 0 to endIndex-1, keeping items from endIndex onwards\n      this.orderByItemsArray.splice(0, endIndex);\n    }\n  }\n\n  protected processRangesForPagination(\n    pageSize: number,\n    isResponseEmpty: boolean = false,\n  ): { endIndex: number; processedRanges: string[] } {\n    // Handle empty response case - update the previous valid continuation token\n    if (isResponseEmpty && this.continuationToken) {\n      let rangeProcessingResult;\n\n      if (this.rangeList.length === 0) {\n        rangeProcessingResult = this.partitionManager.processOrderByRanges(pageSize);\n      } else {\n        rangeProcessingResult = this.partitionManager.processEmptyOrderByRanges(this.rangeList);\n      }\n\n      const { lastRangeBeforePageLimit } = rangeProcessingResult;\n      if (lastRangeBeforePageLimit) {\n        // Use the range matching the continuation token for empty response\n        this.continuationToken.rangeMappings = [\n          convertRangeMappingToQueryRange(lastRangeBeforePageLimit),\n        ];\n      } else {\n        // Range is exhausted - clear the continuation token\n        this.continuationToken = undefined;\n      }\n      return {\n        endIndex: rangeProcessingResult.endIndex,\n        processedRanges: rangeProcessingResult.processedRanges,\n      };\n    }\n\n    // Normal processing path - handle non-empty responses\n    const rangeProcessingResult = this.partitionManager.processOrderByRanges(pageSize);\n    const { lastRangeBeforePageLimit } = rangeProcessingResult;\n\n    // Check if we have a valid range to continue with\n    if (!lastRangeBeforePageLimit) {\n      this.continuationToken = undefined;\n      return {\n        endIndex: rangeProcessingResult.endIndex,\n        processedRanges: rangeProcessingResult.processedRanges,\n      };\n    }\n\n    const queryRange = convertRangeMappingToQueryRange(lastRangeBeforePageLimit);\n\n    // Extract ORDER BY items from the last item on the page\n    let lastOrderByItems: any[] | undefined;\n    let documentRid: string;\n    let skipCount: number = 0;\n    if (rangeProcessingResult.endIndex > 0 && this.orderByItemsArray.length > 0) {\n      const lastItemIndexOnPage = rangeProcessingResult.endIndex - 1;\n\n      if (lastItemIndexOnPage < this.orderByItemsArray.length) {\n        lastOrderByItems = this.orderByItemsArray[lastItemIndexOnPage].orderByItems;\n        documentRid = this.orderByItemsArray[lastItemIndexOnPage]._rid;\n        // Calculate skip count: count how many documents in the page have the same RID\n        // This handles JOIN queries where multiple documents can have the same RID\n        skipCount = 0;\n        for (let i = 0; i <= lastItemIndexOnPage; i++) {\n          if (this.orderByItemsArray[i]._rid === documentRid) {\n            skipCount++;\n          }\n        }\n      }\n    }\n\n    // If we don't have valid ORDER BY items, we cannot create a proper continuation token\n    // This can happen when the response doesn't contain ORDER BY metadata or when there are no results\n    if (!lastOrderByItems || lastOrderByItems.length === 0) {\n      this.continuationToken = undefined;\n      return {\n        endIndex: rangeProcessingResult.endIndex,\n        processedRanges: rangeProcessingResult.processedRanges,\n      };\n    }\n\n    const rangeMappings = [queryRange];\n\n    // Create new ORDER BY continuation token\n    this.continuationToken = createOrderByQueryContinuationToken(\n      rangeMappings,\n      lastOrderByItems,\n      this.collectionLink, // Container RID/link\n      skipCount, // Number of documents with the same RID already processed\n      documentRid, // Document RID from the last item in the page\n      lastRangeBeforePageLimit.offset, // Current offset for OFFSET/LIMIT queries\n      lastRangeBeforePageLimit.limit, // Current limit for OFFSET/LIMIT queries\n      lastRangeBeforePageLimit.hashedLastResult, // Hash for distinct queries\n    );\n\n    return {\n      endIndex: rangeProcessingResult.endIndex,\n      processedRanges: rangeProcessingResult.processedRanges,\n    };\n  }\n\n  protected getCurrentContinuationToken(): OrderByQueryContinuationToken | undefined {\n    return this.continuationToken;\n  }\n\n  protected getSerializationFunction(): (token: OrderByQueryContinuationToken) => string {\n    return serializeOrderByQueryContinuationToken;\n  }\n}\n"]}