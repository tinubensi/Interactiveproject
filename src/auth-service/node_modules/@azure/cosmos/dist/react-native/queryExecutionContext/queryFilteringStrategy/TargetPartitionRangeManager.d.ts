import type { PartitionKeyRange } from "../../index.js";
import type { TargetPartitionRangeStrategy, PartitionRangeFilterResult } from "./TargetPartitionRangeStrategy.js";
/**
 * Interface representing a partition key range with its associated continuation token and filtering condition
 * @hidden
 */
export interface PartitionRangeWithContinuationToken {
    range: PartitionKeyRange;
    continuationToken?: string;
    filteringCondition?: string;
}
/**
 * Query execution context types
 * @hidden
 */
export declare enum QueryExecutionContextType {
    Parallel = "Parallel",
    OrderBy = "OrderBy"
}
/**
 * Configuration for the Target Partition Range Manager
 * @hidden
 */
export interface TargetPartitionRangeManagerConfig {
    /**
     * The type of query execution context
     */
    queryType: QueryExecutionContextType;
    /**
     * Additional query information that might be needed for filtering decisions
     */
    queryInfo: Record<string, unknown>;
    /**
     * Custom strategy instance (optional, will use default strategies if not provided)
     */
    customStrategy?: TargetPartitionRangeStrategy;
}
/**
 * Manager class responsible for filtering target partition ranges based on query type and continuation tokens.
 * Uses the Strategy pattern to provide different filtering logic for different query types.
 * @hidden
 */
export declare class TargetPartitionRangeManager {
    private strategy;
    private config;
    constructor(config: TargetPartitionRangeManagerConfig);
    /**
     * Creates the appropriate strategy based on configuration
     */
    private createStrategy;
    /**
     * Filters target partition ranges based on range-token pairs from partition split/merge detection
     * @param targetRanges - All available target partition ranges (fallback if no range-token pairs)
     * @param rangeTokenPairs - Pre-processed range-token pairs after split/merge detection
     * @param additionalQueryInfo - Additional query information to merge with existing queryInfo
     * @returns Filtered partition ranges and metadata
     */
    filterPartitionRanges(targetRanges: PartitionKeyRange[], rangeTokenPairs?: PartitionRangeWithContinuationToken[], additionalQueryInfo?: Record<string, unknown>): PartitionRangeFilterResult;
    /**
     * Gets the current strategy type
     */
    getStrategyType(): string;
    /**
     * Updates the strategy (useful for switching between query types)
     */
    updateStrategy(newConfig: TargetPartitionRangeManagerConfig): void;
    /**
     * Static factory method to create a manager for parallel queries
     */
    static createForParallelQuery(queryInfo: Record<string, unknown>): TargetPartitionRangeManager;
    /**
     * Static factory method to create a manager for ORDER BY queries
     */
    static createForOrderByQuery(queryInfo: Record<string, unknown>): TargetPartitionRangeManager;
}
//# sourceMappingURL=TargetPartitionRangeManager.d.ts.map