{"version":3,"file":"parallelQueryExecutionContextBase.js","sourceRoot":"","sources":["../../../src/queryExecutionContext/parallelQueryExecutionContextBase.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport PriorityQueue from \"priorityqueuejs\";\nimport semaphore from \"semaphore\";\nimport { StatusCodes, SubStatusCodes } from \"../common/statusCodes.js\";\nimport type { FeedOptions, Response } from \"../request/index.js\";\nimport type { PartitionedQueryExecutionInfo } from \"../request/ErrorResponse.js\";\nimport { ErrorResponse } from \"../request/ErrorResponse.js\";\nimport { QueryRange } from \"../routing/QueryRange.js\";\nimport { SmartRoutingMapProvider } from \"../routing/smartRoutingMapProvider.js\";\nimport type { CosmosHeaders, PartitionKeyRange } from \"../index.js\";\nimport type { ExecutionContext } from \"./ExecutionContext.js\";\nimport type { SqlQuerySpec } from \"./SqlQuerySpec.js\";\nimport { DocumentProducer } from \"./documentProducer.js\";\nimport { getInitialHeader, mergeHeaders } from \"./headerUtils.js\";\nimport type { FilterContext, FilterStrategy } from \"./queryFilteringStrategy/FilterStrategy.js\";\nimport { RidSkipCountFilter } from \"./queryFilteringStrategy/RidSkipCountFilter.js\";\nimport { TargetPartitionRangeManager } from \"./queryFilteringStrategy/TargetPartitionRangeManager.js\";\nimport type { QueryProcessingStrategy } from \"./queryProcessingStrategy/QueryProcessingStrategy.js\";\nimport {\n  DiagnosticNodeInternal,\n  DiagnosticNodeType,\n} from \"../diagnostics/DiagnosticNodeInternal.js\";\nimport type { ClientContext } from \"../ClientContext.js\";\nimport type { QueryRangeMapping } from \"./queryRangeMapping.js\";\nimport type {\n  QueryRangeWithContinuationToken,\n  RangeBoundary,\n  BaseContinuationToken,\n} from \"../documents/ContinuationToken/CompositeQueryContinuationToken.js\";\nimport { createParallelQueryResult } from \"./parallelQueryResult.js\";\nimport type {\n  PartitionRangeUpdate,\n  PartitionRangeUpdates,\n} from \"../documents/ContinuationToken/PartitionRangeUpdate.js\";\n\n/** @hidden */\nexport enum ParallelQueryExecutionContextBaseStates {\n  started = \"started\",\n  inProgress = \"inProgress\",\n  ended = \"ended\",\n}\n\n/** @hidden */\nexport abstract class ParallelQueryExecutionContextBase implements ExecutionContext {\n  private err: any;\n  private state: any;\n  private static readonly STATES = ParallelQueryExecutionContextBaseStates;\n  private routingProvider: SmartRoutingMapProvider;\n  private readonly requestContinuation: any;\n  private respHeaders: CosmosHeaders;\n  private readonly unfilledDocumentProducersQueue: PriorityQueue<DocumentProducer>;\n  private readonly bufferedDocumentProducersQueue: PriorityQueue<DocumentProducer>;\n  // TODO: update type of buffer from any --> generic can be used here\n  private buffer: any[];\n  private partitionDataPatchMap: Map<string, QueryRangeMapping> = new Map();\n  private patchCounter: number = 0;\n  private readonly updatedContinuationRanges: Map<string, PartitionRangeUpdate> = new Map();\n  private readonly sem: any;\n  private readonly diagnosticNodeWrapper: {\n    consumed: boolean;\n    diagnosticNode: DiagnosticNodeInternal;\n  };\n  /**\n   * Provides the ParallelQueryExecutionContextBase.\n   * This is the base class that ParallelQueryExecutionContext and OrderByQueryExecutionContext will derive from.\n   *\n   * When handling a parallelized query, it instantiates one instance of\n   * DocumentProcuder per target partition key range and aggregates the result of each.\n   *\n   * @param clientContext - The service endpoint to use to create the client.\n   * @param collectionLink - The Collection Link\n   * @param options - Represents the feed options.\n   * @param partitionedQueryExecutionInfo - PartitionedQueryExecutionInfo\n   * @hidden\n   */\n  constructor(\n    private readonly clientContext: ClientContext,\n    private readonly collectionLink: string,\n    private readonly query: string | SqlQuerySpec,\n    private readonly options: FeedOptions,\n    private readonly partitionedQueryExecutionInfo: PartitionedQueryExecutionInfo,\n    private readonly correlatedActivityId: string,\n    private readonly rangeManager: TargetPartitionRangeManager,\n    private readonly queryProcessingStrategy: QueryProcessingStrategy,\n    private readonly documentProducerComparator: (\n      dp1: DocumentProducer,\n      dp2: DocumentProducer,\n    ) => number,\n  ) {\n    this.clientContext = clientContext;\n    this.collectionLink = collectionLink;\n    this.query = query;\n    this.options = options;\n    this.partitionedQueryExecutionInfo = partitionedQueryExecutionInfo;\n    this.correlatedActivityId = correlatedActivityId;\n    this.diagnosticNodeWrapper = {\n      consumed: false,\n      diagnosticNode: new DiagnosticNodeInternal(\n        clientContext.diagnosticLevel,\n        DiagnosticNodeType.PARALLEL_QUERY_NODE,\n        null,\n      ),\n    };\n    this.diagnosticNodeWrapper.diagnosticNode.addData({ stateful: true });\n    this.err = undefined;\n    this.state = ParallelQueryExecutionContextBase.STATES.started;\n    this.routingProvider = new SmartRoutingMapProvider(this.clientContext);\n    this.buffer = [];\n    this.requestContinuation = options\n      ? options.continuationToken || options.continuation\n      : undefined;\n\n    // Validate continuation token usage immediately\n    if (this.requestContinuation && !this.options.enableQueryControl) {\n      throw new Error(\n        \"Continuation tokens are supported when enableQueryControl is set true in FeedOptions\",\n      );\n    }\n\n    // response headers of undergoing operation\n    this.respHeaders = getInitialHeader();\n    // Make priority queue for documentProducers\n    this.unfilledDocumentProducersQueue = new PriorityQueue<DocumentProducer>(\n      (a: DocumentProducer, b: DocumentProducer) => this.compareDocumentProducersByRange(a, b),\n    );\n    this.bufferedDocumentProducersQueue = new PriorityQueue<DocumentProducer>(\n      (a: DocumentProducer, b: DocumentProducer) => this.documentProducerComparator(b, a),\n    );\n    // Creating the documentProducers\n    this.sem = semaphore(1);\n    this.sem.take(() => this._initializeDocumentProducers());\n  }\n\n  /**\n   * Determine if there are still remaining resources to processs based on the value of the continuation\n   * token or the elements remaining on the current batch in the QueryIterator.\n   * @returns true if there is other elements to process in the ParallelQueryExecutionContextBase.\n   */\n  public hasMoreResults(): boolean {\n    return (\n      !this.err &&\n      (this.buffer.length > 0 || this.state !== ParallelQueryExecutionContextBase.STATES.ended)\n    );\n  }\n\n  /**\n   * Fetches more results from the query execution context.\n   * @param diagnosticNode - Optional diagnostic node for tracing.\n   * @returns A promise that resolves to the fetched results.\n   * @hidden\n   */\n  public async fetchMore(diagnosticNode?: DiagnosticNodeInternal): Promise<Response<any>> {\n    await this.bufferDocumentProducers(diagnosticNode);\n    await this.fillBufferFromBufferQueue();\n    return this.drainBufferedItems();\n  }\n\n  /**\n   * Processes buffered document producers\n   * @returns A promise that resolves when processing is complete.\n   */\n  private async processBufferedDocumentProducers(): Promise<void> {\n    while (\n      this.hasBufferedProducers() &&\n      this.shouldProcessBufferedProducers(this.isUnfilledQueueEmpty())\n    ) {\n      const producer = this.getNextBufferedProducer();\n      if (!producer) break;\n\n      await this.processDocumentProducer(producer);\n    }\n  }\n\n  /**\n   * Processes a single document producer using template method pattern.\n   * Common structure with query-specific processing delegated to subclasses.\n   */\n  private async processDocumentProducer(producer: DocumentProducer): Promise<void> {\n    const response = await this.fetchFromProducer(producer);\n    this._mergeWithActiveResponseHeaders(response.headers);\n\n    if (response.result) {\n      this.addToBuffer(response.result);\n      this.handlePartitionMapping(producer, response.result);\n    }\n\n    // Handle producer lifecycle\n    if (producer.peakNextItem() !== undefined) {\n      this.requeueProducer(producer);\n    } else if (producer.hasMoreResults()) {\n      this.moveToUnfilledQueue(producer);\n    }\n  }\n\n  /**\n   * Fetches data from a document producer - implemented by subclasses.\n   */\n  protected abstract fetchFromProducer(producer: DocumentProducer): Promise<Response<any>>;\n\n  /**\n   * Handles partition mapping updates - implemented in base class using template method pattern.\n   * Child classes provide query-specific parameters through abstract methods.\n   */\n  private handlePartitionMapping(producer: DocumentProducer, result: any): void {\n    const itemCount = result?.length || 0;\n    const continuationToken = this.getContinuationToken(producer);\n    const mapping = {\n      itemCount,\n      partitionKeyRange: producer.targetPartitionKeyRange,\n      continuationToken,\n    };\n\n    this.updatePartitionMapping(mapping);\n  }\n\n  /**\n   * Gets the continuation token to use - implemented by subclasses.\n   */\n  private getContinuationToken(producer: DocumentProducer): string {\n    const hasMoreBufferedItems = producer.peakNextItem() !== undefined;\n    return hasMoreBufferedItems ? producer.previousContinuationToken : producer.continuationToken;\n  }\n  /**\n   * Determines if buffered producers should continue to be processed based on query-specific rules.\n   * @param isUnfilledQueueEmpty - Whether the unfilled queue is empty\n   */\n  protected abstract shouldProcessBufferedProducers(isUnfilledQueueEmpty: boolean): boolean;\n\n  /**\n   * Updates partition mapping - creates new entry or merges with existing for ORDER BY queries.\n   */\n  private updatePartitionMapping(mapping: QueryRangeMapping): void {\n    const currentPatch = this.partitionDataPatchMap.get(this.patchCounter.toString());\n    const isSamePartition = currentPatch?.partitionKeyRange?.id === mapping.partitionKeyRange.id;\n\n    if (isSamePartition && currentPatch) {\n      currentPatch.itemCount += mapping.itemCount;\n      currentPatch.continuationToken = mapping.continuationToken;\n      return;\n    }\n    // Create new partition mapping entry\n    this.partitionDataPatchMap.set((++this.patchCounter).toString(), mapping);\n  }\n\n  /**\n   * Checks if the unfilled queue is empty (used by ORDER BY for processing control).\n   */\n  protected isUnfilledQueueEmpty(): boolean {\n    return this.unfilledDocumentProducersQueue.size() === 0;\n  }\n\n  /**\n   * Initializes document producers and fills the priority queue.\n   * Handles both continuation token and fresh query scenarios.\n   */\n  private async _initializeDocumentProducers(): Promise<void> {\n    try {\n      const targetPartitionRanges = await this._onTargetPartitionRanges();\n      const documentProducers = this.requestContinuation\n        ? await this._createDocumentProducersFromContinuation(targetPartitionRanges)\n        : this._createDocumentProducersFromFresh(targetPartitionRanges);\n\n      // Fill up our priority queue with documentProducers\n      this._enqueueDocumentProducers(documentProducers);\n      this.sem.leave();\n    } catch (err: any) {\n      this.err = err;\n      this.sem.leave();\n    }\n  }\n\n  /**\n   * Creates document producers from continuation token scenario.\n   */\n  private async _createDocumentProducersFromContinuation(\n    targetPartitionRanges: any[],\n  ): Promise<DocumentProducer[]> {\n    // Parse continuation token to get range mappings and check for split/merge scenarios\n    const parsedToken = this._parseContinuationToken(this.requestContinuation);\n    const continuationRanges = await this._handlePartitionRangeChanges(parsedToken);\n\n    // Use strategy to create additional query info from parsed token\n    const additionalQueryInfo = this.queryProcessingStrategy.createAdditionalQueryInfo(parsedToken);\n\n    const filterResult = this.rangeManager.filterPartitionRanges(\n      targetPartitionRanges,\n      continuationRanges,\n      additionalQueryInfo,\n    );\n\n    // Extract ranges and tokens from the combined result\n    const rangeTokenPairs = filterResult.rangeTokenPairs;\n\n    // Use strategy to create filter context for continuation token processing\n    const filterContext = this.queryProcessingStrategy.createFilterContext(parsedToken);\n\n    return rangeTokenPairs.map((rangeTokenPair) =>\n      this._createDocumentProducerFromRangeTokenPair(\n        rangeTokenPair,\n        continuationRanges,\n        filterContext,\n      ),\n    );\n  }\n\n  /**\n   * Creates document producers from fresh query scenario (no continuation token).\n   */\n  private _createDocumentProducersFromFresh(targetPartitionRanges: any[]): DocumentProducer[] {\n    return targetPartitionRanges.map((partitionTargetRange: any) =>\n      this._createTargetPartitionQueryExecutionContext(partitionTargetRange, undefined),\n    );\n  }\n\n  /**\n   * Creates a document producer from a range token pair (continuation token scenario).\n   */\n  private _createDocumentProducerFromRangeTokenPair(\n    rangeTokenPair: any,\n    continuationRanges: any[],\n    filterContext: any,\n  ): DocumentProducer {\n    const partitionTargetRange = rangeTokenPair.range;\n    const continuationToken = rangeTokenPair.continuationToken;\n    const filterCondition = rangeTokenPair.filteringCondition || undefined;\n\n    // Find EPK ranges for this partition range from processed continuation response\n    const matchingContinuationRange = continuationRanges.find(\n      (cr) => cr.range.id === partitionTargetRange.id,\n    );\n    const startEpk = matchingContinuationRange?.epkMin;\n    const endEpk = matchingContinuationRange?.epkMax;\n\n    // Use strategy to determine partition-specific filter context\n    const targetPartitionId =\n      continuationRanges.length > 0 && continuationRanges[continuationRanges.length - 1].range\n        ? continuationRanges[continuationRanges.length - 1].range.id\n        : undefined;\n    const partitionFilterContext = this.queryProcessingStrategy.getPartitionFilterContext(\n      filterContext,\n      targetPartitionId,\n      partitionTargetRange.id,\n    );\n\n    return this._createTargetPartitionQueryExecutionContext(\n      partitionTargetRange,\n      continuationToken,\n      startEpk,\n      endEpk,\n      !!(startEpk && endEpk), // populateEpkRangeHeaders - true if both EPK values are present\n      filterCondition,\n      partitionFilterContext,\n    );\n  }\n\n  /**\n   * Enqueues document producers into the unfilled queue.\n   */\n  private _enqueueDocumentProducers(documentProducers: DocumentProducer[]): void {\n    documentProducers.forEach((documentProducer) => {\n      try {\n        this.unfilledDocumentProducersQueue.enq(documentProducer);\n      } catch (e: any) {\n        this.err = e;\n      }\n    });\n  }\n\n  /**\n   * Checks if there are buffered document producers ready for processing.\n   * Encapsulates queue size checking.\n   */\n  private hasBufferedProducers(): boolean {\n    return this.bufferedDocumentProducersQueue.size() > 0;\n  }\n\n  /**\n   * Gets the next buffered document producer for processing.\n   * Encapsulates queue dequeuing logic.\n   */\n  private getNextBufferedProducer(): DocumentProducer | undefined {\n    if (this.bufferedDocumentProducersQueue.size() > 0) {\n      return this.bufferedDocumentProducersQueue.deq();\n    }\n    return undefined;\n  }\n\n  /**\n   * Adds items to the result buffer. Handles both single items and arrays.\n   */\n  private addToBuffer(items: any[] | any): void {\n    if (Array.isArray(items)) {\n      if (items.length > 0) {\n        this.buffer.push(...items);\n      }\n    } else if (items) {\n      this.buffer.push(items);\n    }\n  }\n\n  /**\n   * Moves a producer to the unfilled queue for later processing.\n   */\n  private moveToUnfilledQueue(producer: DocumentProducer): void {\n    this.unfilledDocumentProducersQueue.enq(producer);\n  }\n\n  /**\n   * Re-queues a producer to the buffered queue for further processing.\n   */\n  private requeueProducer(producer: DocumentProducer): void {\n    this.bufferedDocumentProducersQueue.enq(producer);\n  }\n\n  /**\n   * Compares two document producers based on their partition key ranges and EPK values.\n   * Primary comparison: minInclusive values for left-to-right range traversal\n   * Secondary comparison: EPK ranges when minInclusive values are identical\n   * @param a - First document producer\n   * @param b - Second document producer\n   * @returns Comparison result for priority queue ordering\n   * @hidden\n   */\n  private compareDocumentProducersByRange(a: DocumentProducer, b: DocumentProducer): number {\n    const aMinInclusive = a.targetPartitionKeyRange.minInclusive;\n    const bMinInclusive = b.targetPartitionKeyRange.minInclusive;\n    const minInclusiveComparison = bMinInclusive.localeCompare(aMinInclusive);\n\n    // If minInclusive values are the same, check minEPK ranges if they exist\n    if (minInclusiveComparison === 0) {\n      const aMinEpk = a.startEpk;\n      const bMinEpk = b.startEpk;\n      if (aMinEpk && bMinEpk) {\n        return bMinEpk.localeCompare(aMinEpk);\n      }\n    }\n\n    return minInclusiveComparison;\n  }\n\n  /**\n   * Detects partition splits/merges by analyzing parsed continuation token ranges and comparing with current topology\n   * @param parsed - The continuation token containing range mappings to analyze\n   * @returns Array of processed ranges with EPK info\n   */\n  private async _handlePartitionRangeChanges(\n    parsed: BaseContinuationToken,\n  ): Promise<{ range: any; continuationToken?: string; epkMin?: string; epkMax?: string }[]> {\n    const processedRanges: {\n      range: any;\n      continuationToken?: string;\n      epkMin?: string;\n      epkMax?: string;\n    }[] = [];\n\n    // Extract range mappings from the already parsed token\n    const rangeMappings = parsed.rangeMappings;\n\n    if (!rangeMappings || rangeMappings.length === 0) {\n      return [];\n    }\n\n    // Check each range mapping for potential splits/merges\n    for (const rangeWithToken of rangeMappings) {\n      // Create a new QueryRange instance from the simplified range data\n      const range = rangeWithToken.queryRange;\n      const queryRange: QueryRange = new QueryRange(\n        range.min,\n        range.max,\n        true, // isMinInclusive - assumption: always true\n        false, // isMaxInclusive - assumption: always false (max is exclusive)\n      );\n\n      const rangeMin = queryRange.min;\n      const rangeMax = queryRange.max;\n\n      // Get current overlapping ranges for this continuation token range\n      const overlappingRanges = await this.routingProvider.getOverlappingRanges(\n        this.collectionLink,\n        [queryRange],\n        this.getDiagnosticNode(),\n      );\n\n      // Detect split/merge scenario based on the number of overlapping ranges\n      if (overlappingRanges.length === 0) {\n        continue;\n      } else if (overlappingRanges.length === 1) {\n        // Check if it's the same range (no change) or a merge scenario\n        const currentRange = overlappingRanges[0];\n        if (currentRange.minInclusive !== rangeMin || currentRange.maxExclusive !== rangeMax) {\n          // Merge scenario - include EPK ranges from original continuation token range\n          await this._handleContinuationTokenMerge(rangeWithToken, currentRange);\n          processedRanges.push({\n            range: currentRange,\n            continuationToken: rangeWithToken.continuationToken,\n            epkMin: rangeMin, // Original range min becomes EPK min\n            epkMax: rangeMax, // Original range max becomes EPK max\n          });\n        } else {\n          // Same range - no merge, no EPK ranges needed\n          processedRanges.push({\n            range: currentRange,\n            continuationToken: rangeWithToken.continuationToken,\n          });\n        }\n      } else {\n        // Split scenario - one range from continuation token now maps to multiple ranges\n        await this._handleContinuationTokenSplit(rangeWithToken, overlappingRanges);\n        // Add all overlapping ranges with the same continuation token to processed ranges\n        overlappingRanges.forEach((rangeValue) => {\n          processedRanges.push({\n            range: rangeValue,\n            continuationToken: rangeWithToken.continuationToken,\n          });\n        });\n      }\n    }\n\n    return processedRanges;\n  }\n\n  /**\n   * Parses the continuation token based on query type\n   * @param continuationToken - The continuation token string to parse\n   * @returns Parsed continuation token object (ORDER BY or Parallel query token)\n   * @throws ErrorResponse when continuation token is malformed or cannot be parsed\n   */\n  private _parseContinuationToken(continuationToken: string): BaseContinuationToken {\n    try {\n      return this.queryProcessingStrategy.parseContinuationToken(continuationToken);\n    } catch (e) {\n      throw new ErrorResponse(\n        `Invalid continuation token format. Expected token with rangeMappings property. ` +\n          `Ensure the continuation token was generated by a compatible query and has not been modified.`,\n      );\n    }\n  }\n\n  /**\n   * Handles partition merge scenario for continuation token ranges\n   */\n  private async _handleContinuationTokenMerge(\n    rangeWithToken: QueryRangeWithContinuationToken,\n    _newMergedRange: PartitionKeyRange,\n  ): Promise<void> {\n    const rangeKey = `${rangeWithToken.queryRange.min}-${rangeWithToken.queryRange.max}`;\n    this.updatedContinuationRanges.set(rangeKey, {\n      oldRange: {\n        min: rangeWithToken.queryRange.min,\n        max: rangeWithToken.queryRange.max,\n        isMinInclusive: true, // Assumption: min is always inclusive\n        isMaxInclusive: false, // Assumption: max is always exclusive\n      },\n      newRanges: [\n        {\n          min: rangeWithToken.queryRange.min,\n          max: rangeWithToken.queryRange.max,\n          isMinInclusive: true, // Assumption: min is always inclusive\n          isMaxInclusive: false, // Assumption: max is always exclusive\n        },\n      ],\n      continuationToken: rangeWithToken.continuationToken,\n    });\n  }\n\n  /**\n   * Handles partition split scenario for continuation token ranges\n   */\n  private async _handleContinuationTokenSplit(\n    rangeWithToken: QueryRangeWithContinuationToken,\n    overlappingRanges: any[],\n  ): Promise<void> {\n    const rangeKey = `${rangeWithToken.queryRange.min}-${rangeWithToken.queryRange.max}`;\n    this.updatedContinuationRanges.set(rangeKey, {\n      oldRange: {\n        min: rangeWithToken.queryRange.min,\n        max: rangeWithToken.queryRange.max,\n        isMinInclusive: true, // Assumption: min is always inclusive\n        isMaxInclusive: false, // Assumption: max is always exclusive\n      },\n      newRanges: overlappingRanges.map((range) => ({\n        min: range.minInclusive,\n        max: range.maxExclusive,\n        isMinInclusive: true,\n        isMaxInclusive: false,\n      })),\n      continuationToken: rangeWithToken.continuationToken,\n    });\n  }\n\n  /**\n   * Handles partition merge scenario for continuation token ranges\n   */\n  private _mergeWithActiveResponseHeaders(headers: CosmosHeaders): void {\n    mergeHeaders(this.respHeaders, headers);\n  }\n\n  private _getAndResetActiveResponseHeaders(): CosmosHeaders {\n    const ret = this.respHeaders;\n    this.respHeaders = getInitialHeader();\n    return ret;\n  }\n\n  private getDiagnosticNode(): DiagnosticNodeInternal {\n    return this.diagnosticNodeWrapper.diagnosticNode;\n  }\n\n  private async _onTargetPartitionRanges(): Promise<any[]> {\n    // invokes the callback when the target partition ranges are ready\n    const parsedRanges = this.partitionedQueryExecutionInfo.queryRanges;\n    const queryRanges = parsedRanges.map((item) => QueryRange.parseFromDict(item));\n    return this.routingProvider.getOverlappingRanges(\n      this.collectionLink,\n      queryRanges,\n      this.getDiagnosticNode(),\n    );\n  }\n\n  /**\n   * Gets the replacement ranges for a partitionkeyrange that has been split\n   */\n  private async _getReplacementPartitionKeyRanges(\n    documentProducer: DocumentProducer,\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<any[]> {\n    const partitionKeyRange = documentProducer.targetPartitionKeyRange;\n    // Download the new routing map\n    this.routingProvider = new SmartRoutingMapProvider(this.clientContext);\n    // Get the queryRange that relates to this partitionKeyRange\n    const queryRange = QueryRange.parsePartitionKeyRange(partitionKeyRange);\n    return this.routingProvider.getOverlappingRanges(\n      this.collectionLink,\n      [queryRange],\n      diagnosticNode,\n    );\n  }\n\n  private async _enqueueReplacementDocumentProducers(\n    error: any,\n    diagnosticNode: DiagnosticNodeInternal,\n    documentProducer: DocumentProducer,\n  ): Promise<void> {\n    // Get the replacement ranges\n    const replacementPartitionKeyRanges = await this._getReplacementPartitionKeyRanges(\n      documentProducer,\n      diagnosticNode,\n    );\n\n    if (replacementPartitionKeyRanges.length === 0) {\n      throw error;\n    }\n\n    if (this.requestContinuation) {\n      // Update composite continuation token to handle partition split\n      this._updateContinuationTokenOnPartitionChange(\n        documentProducer,\n        replacementPartitionKeyRanges,\n      );\n    }\n\n    if (replacementPartitionKeyRanges.length === 1) {\n      // Partition is gone due to Merge\n      // Create the replacement documentProducer with populateEpkRangeHeaders Flag set to true to set startEpk and endEpk headers\n      const replacementDocumentProducer = this._createTargetPartitionQueryExecutionContext(\n        replacementPartitionKeyRanges[0],\n        documentProducer.continuationToken,\n        documentProducer.startEpk,\n        documentProducer.endEpk,\n        true,\n      );\n\n      this.unfilledDocumentProducersQueue.enq(replacementDocumentProducer);\n    } else {\n      // Create the replacement documentProducers\n      const replacementDocumentProducers: DocumentProducer[] = [];\n      replacementPartitionKeyRanges.forEach((partitionKeyRange) => {\n        const queryRange = QueryRange.parsePartitionKeyRange(partitionKeyRange);\n        // Create replacment document producers with the parent's continuationToken\n        const replacementDocumentProducer = this._createTargetPartitionQueryExecutionContext(\n          partitionKeyRange,\n          documentProducer.continuationToken,\n          queryRange.min,\n          queryRange.max,\n          false,\n        );\n        replacementDocumentProducers.push(replacementDocumentProducer);\n      });\n\n      // add document producers to the queue\n      replacementDocumentProducers.forEach((replacementDocumentProducer) => {\n        if (replacementDocumentProducer.hasMoreResults()) {\n          this.unfilledDocumentProducersQueue.enq(replacementDocumentProducer);\n        }\n      });\n    }\n  }\n\n  private _updateContinuationTokenOnPartitionChange(\n    originalDocumentProducer: DocumentProducer,\n    replacementPartitionKeyRanges: any[],\n  ): void {\n    const rangeWithToken = this._createQueryRangeWithContinuationToken(originalDocumentProducer);\n    if (replacementPartitionKeyRanges.length === 1) {\n      this._handleContinuationTokenMerge(rangeWithToken, replacementPartitionKeyRanges[0]);\n    } else {\n      this._handleContinuationTokenSplit(rangeWithToken, replacementPartitionKeyRanges);\n    }\n  }\n\n  /**\n   * Creates a QueryRangeWithContinuationToken object from a DocumentProducer.\n   * Uses the DocumentProducer's target partition key range and continuation token.\n   * @param documentProducer - The DocumentProducer to convert\n   * @returns QueryRangeWithContinuationToken object for token operations\n   */\n  private _createQueryRangeWithContinuationToken(\n    documentProducer: DocumentProducer,\n  ): QueryRangeWithContinuationToken {\n    const partitionRange = documentProducer.targetPartitionKeyRange;\n\n    // Create a simplified QueryRange using the partition key range boundaries\n    const simplifiedQueryRange: RangeBoundary = {\n      min: documentProducer.startEpk || partitionRange.minInclusive,\n      max: documentProducer.endEpk || partitionRange.maxExclusive,\n    };\n\n    return {\n      queryRange: simplifiedQueryRange,\n      continuationToken: documentProducer.continuationToken,\n    };\n  }\n\n  private static _needPartitionKeyRangeCacheRefresh(error: any): boolean {\n    // TODO: any error\n    return (\n      error.code === StatusCodes.Gone &&\n      \"substatus\" in error &&\n      error[\"substatus\"] === SubStatusCodes.PartitionKeyRangeGone\n    );\n  }\n\n  /**\n   * Creates target partition range Query Execution Context\n   */\n  private _createTargetPartitionQueryExecutionContext(\n    partitionKeyTargetRange: any,\n    continuationToken?: any,\n    startEpk?: string,\n    endEpk?: string,\n    populateEpkRangeHeaders?: boolean,\n    filterCondition?: string,\n    filterContext?: FilterContext,\n  ): DocumentProducer {\n    let rewrittenQuery = this.partitionedQueryExecutionInfo.queryInfo?.rewrittenQuery;\n    let sqlQuerySpec: SqlQuerySpec;\n    const query = this.query;\n    if (typeof query === \"string\") {\n      sqlQuerySpec = { query };\n    } else {\n      sqlQuerySpec = query;\n    }\n\n    const formatPlaceHolder = \"{documentdb-formattableorderbyquery-filter}\";\n    if (rewrittenQuery) {\n      sqlQuerySpec = JSON.parse(JSON.stringify(sqlQuerySpec));\n      rewrittenQuery = filterCondition\n        ? rewrittenQuery.replace(formatPlaceHolder, filterCondition)\n        : rewrittenQuery.replace(formatPlaceHolder, \"true\");\n      sqlQuerySpec[\"query\"] = rewrittenQuery;\n    }\n\n    const options = { ...this.options };\n    options.continuationToken = continuationToken;\n\n    let filter: FilterStrategy | undefined;\n    if (filterContext) {\n      filter = new RidSkipCountFilter(filterContext);\n    }\n\n    return new DocumentProducer(\n      this.clientContext,\n      this.collectionLink,\n      sqlQuerySpec,\n      partitionKeyTargetRange,\n      options,\n      this.correlatedActivityId,\n      startEpk,\n      endEpk,\n      populateEpkRangeHeaders,\n      filter,\n    );\n  }\n  private async drainBufferedItems(): Promise<Response<any>> {\n    return new Promise<Response<any>>((resolve, reject) => {\n      this.sem.take(() => {\n        if (this.err) {\n          // if there is a prior error return error\n          this.sem.leave();\n          this.err.headers = this._getAndResetActiveResponseHeaders();\n          reject(this.err);\n          return;\n        }\n\n        // return undefined if there is no more results\n        if (this.buffer.length === 0) {\n          this.sem.leave();\n          const partitionDataPatchMap = this.partitionDataPatchMap;\n          this.partitionDataPatchMap = new Map<string, QueryRangeMapping>();\n          this.patchCounter = 0;\n          // Get and reset updated continuation ranges\n          const updatedContinuationRanges: PartitionRangeUpdates = Object.fromEntries(\n            this.updatedContinuationRanges,\n          );\n          this.updatedContinuationRanges.clear();\n          const result = createParallelQueryResult(\n            [],\n            partitionDataPatchMap,\n            updatedContinuationRanges,\n            undefined,\n          );\n\n          return resolve({\n            result:\n              this.state === ParallelQueryExecutionContextBase.STATES.ended ? undefined : result,\n            headers: this._getAndResetActiveResponseHeaders(),\n          });\n        }\n        // draing the entire buffer object and return that in result of return object\n        const bufferedResults = this.buffer;\n        this.buffer = [];\n        // reset the patchToRangeMapping\n        const partitionDataPatchMap = this.partitionDataPatchMap;\n        this.partitionDataPatchMap = new Map<string, QueryRangeMapping>();\n        this.patchCounter = 0;\n\n        // Get and reset updated continuation ranges\n        const updatedContinuationRanges: PartitionRangeUpdates = Object.fromEntries(\n          this.updatedContinuationRanges,\n        );\n        this.updatedContinuationRanges.clear();\n\n        // release the lock before returning\n        this.sem.leave();\n\n        const result = createParallelQueryResult(\n          bufferedResults,\n          partitionDataPatchMap,\n          updatedContinuationRanges,\n          undefined,\n        );\n\n        return resolve({\n          result,\n          headers: this._getAndResetActiveResponseHeaders(),\n        });\n      });\n    });\n  }\n\n  /**\n   * Buffers document producers based on the maximum degree of parallelism.\n   * Moves document producers from the unfilled queue to the buffered queue.\n   * @param diagnosticNode - The diagnostic node for logging and tracing.\n   * @returns A promise that resolves when buffering is complete.\n   */\n  private async bufferDocumentProducers(diagnosticNode?: DiagnosticNodeInternal): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      this.sem.take(async () => {\n        if (this.err) {\n          this.sem.leave();\n          reject(this.err);\n          return;\n        }\n        this.updateStates(this.err);\n\n        if (this.state === ParallelQueryExecutionContextBase.STATES.ended) {\n          this.sem.leave();\n          resolve();\n          return;\n        }\n\n        if (this.unfilledDocumentProducersQueue.size() === 0) {\n          this.sem.leave();\n          resolve();\n          return;\n        }\n\n        try {\n          const maxDegreeOfParallelism =\n            this.options.maxDegreeOfParallelism === undefined ||\n            this.options.maxDegreeOfParallelism < 1\n              ? this.unfilledDocumentProducersQueue.size() // number of partitions\n              : Math.min(\n                  this.options.maxDegreeOfParallelism,\n                  this.unfilledDocumentProducersQueue.size(),\n                );\n\n          const documentProducers: DocumentProducer[] = [];\n          while (\n            documentProducers.length < maxDegreeOfParallelism &&\n            this.unfilledDocumentProducersQueue.size() > 0\n          ) {\n            let documentProducer: DocumentProducer;\n            try {\n              documentProducer = this.unfilledDocumentProducersQueue.deq();\n            } catch (e: any) {\n              this.err = e;\n              this.err.headers = this._getAndResetActiveResponseHeaders();\n              reject(this.err);\n              return;\n            }\n            documentProducers.push(documentProducer);\n          }\n\n          const bufferDocumentProducer = async (\n            documentProducer: DocumentProducer,\n          ): Promise<void> => {\n            try {\n              const headers = await documentProducer.bufferMore(diagnosticNode);\n              this._mergeWithActiveResponseHeaders(headers);\n\n              // Always track this document producer in patchToRangeMapping, even if it has no results\n              // This ensures we maintain a record of all partition ranges that were scanned\n              const nextItem = documentProducer.peakNextItem();\n              if (nextItem !== undefined) {\n                this.bufferedDocumentProducersQueue.enq(documentProducer);\n              } else {\n                // Track document producer with no results in patchToRangeMapping\n                // This represents a scanned partition that yielded no results\n                // IMPORTANT: Only include if continuation token is NOT null/exhausted\n                // Document producers with no data in buffer and no continuation token are exhausted and should not be added to partitionDataPatchMap to prevent infinite loops in order by queries\n                if (\n                  documentProducer.continuationToken &&\n                  documentProducer.continuationToken !== \"\" &&\n                  documentProducer.continuationToken.toLowerCase() !== \"null\"\n                ) {\n                  const patchKey = `empty-${documentProducer.targetPartitionKeyRange.id}-${documentProducer.targetPartitionKeyRange.minInclusive}`;\n                  this.partitionDataPatchMap.set(patchKey, {\n                    itemCount: 0, // 0 items for empty result set\n                    partitionKeyRange: documentProducer.targetPartitionKeyRange,\n                    continuationToken: documentProducer.continuationToken,\n                  });\n                }\n                if (documentProducer.hasMoreResults()) {\n                  this.unfilledDocumentProducersQueue.enq(documentProducer);\n                }\n              }\n            } catch (err) {\n              if (ParallelQueryExecutionContextBase._needPartitionKeyRangeCacheRefresh(err)) {\n                // We want the document producer enqueued\n                // So that later parts of the code can repair the execution context\n                // refresh the partition key ranges and ctreate new document producers and add it to the queue\n                await this._enqueueReplacementDocumentProducers(\n                  err,\n                  diagnosticNode,\n                  documentProducer,\n                );\n                resolve();\n              } else {\n                this.err = err;\n                this.err.headers = this._getAndResetActiveResponseHeaders();\n                reject(err);\n              }\n            }\n          };\n\n          try {\n            await Promise.all(\n              documentProducers.map((producer) => bufferDocumentProducer(producer)),\n            );\n          } catch (err) {\n            this.err = err;\n            this.err.headers = this._getAndResetActiveResponseHeaders();\n            reject(err);\n            return;\n          }\n          resolve();\n        } catch (err) {\n          this.err = err;\n          this.err.headers = this._getAndResetActiveResponseHeaders();\n          reject(err);\n        } finally {\n          this.sem.leave();\n        }\n      });\n    });\n  }\n  /**\n   * Drains the buffer of filled document producers and appends their items to the main buffer.\n   * Uses template method pattern - delegates actual processing to subclasses.\n   * @returns A promise that resolves when the buffer is filled.\n   */\n  private async fillBufferFromBufferQueue(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      this.sem.take(async () => {\n        if (this.err) {\n          // if there is a prior error return error\n          this.sem.leave();\n          this.err.headers = this._getAndResetActiveResponseHeaders();\n          reject(this.err);\n          return;\n        }\n\n        if (\n          this.state === ParallelQueryExecutionContextBase.STATES.ended ||\n          this.bufferedDocumentProducersQueue.size() === 0\n        ) {\n          this.sem.leave();\n          resolve();\n          return;\n        }\n\n        try {\n          await this.processBufferedDocumentProducers();\n          this.updateStates(this.err);\n        } catch (err) {\n          this.err = err;\n          this.err.headers = this._getAndResetActiveResponseHeaders();\n          reject(this.err);\n          return;\n        } finally {\n          // release the lock before returning\n          this.sem.leave();\n        }\n        resolve();\n        return;\n      });\n    });\n  }\n\n  private updateStates(error: any): void {\n    if (error) {\n      this.err = error;\n      this.state = ParallelQueryExecutionContextBase.STATES.ended;\n      return;\n    }\n\n    if (this.state === ParallelQueryExecutionContextBase.STATES.started) {\n      this.state = ParallelQueryExecutionContextBase.STATES.inProgress;\n    }\n\n    const hasNoActiveProducers =\n      this.unfilledDocumentProducersQueue.size() === 0 &&\n      this.bufferedDocumentProducersQueue.size() === 0;\n\n    if (hasNoActiveProducers) {\n      this.state = ParallelQueryExecutionContextBase.STATES.ended;\n    }\n  }\n}\n"]}