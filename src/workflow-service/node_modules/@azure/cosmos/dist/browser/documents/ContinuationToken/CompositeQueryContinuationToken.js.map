{"version":3,"file":"CompositeQueryContinuationToken.js","sourceRoot":"","sources":["../../../../src/documents/ContinuationToken/CompositeQueryContinuationToken.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAElC,OAAO,EAAE,UAAU,EAAE,MAAM,6BAA6B,CAAC;AAiDzD;;;GAGG;AACH,MAAM,UAAU,qCAAqC,CACnD,GAAW,EACX,aAAgD,EAChD,MAAe,EACf,KAAc;IAEd,IAAI,CAAC,aAAa,IAAI,aAAa,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACjD,MAAM,IAAI,KAAK,CACb,uFAAuF;YACrF,mHAAmH;YACnH,uFAAuF,CAC1F,CAAC;IACJ,CAAC;IAED,OAAO;QACL,GAAG;QACH,aAAa,EAAE,aAAa;QAC5B,MAAM;QACN,KAAK;KACN,CAAC;AACJ,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,uBAAuB,CAAC,KAAsC;IAC5E,OAAO,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;AAC/B,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,oCAAoC,CAClD,WAAmB;IAEnB,OAAO,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;AACjC,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,0BAA0B,CAAC,WAAmB;IAC5D,OAAO,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;AACjC,CAAC;AAkBD;;;;;GAKG;AACH,MAAM,UAAU,+BAA+B,CAC7C,YAA+B;IAE/B,IAAI,CAAC,YAAY,CAAC,iBAAiB,EAAE,CAAC;QACpC,MAAM,IAAI,KAAK,CACb,4EAA4E;YAC1E,mGAAmG;YACnG,oFAAoF,CACvF,CAAC;IACJ,CAAC;IAED,MAAM,OAAO,GAAG,YAAY,CAAC,iBAAiB,CAAC;IAE/C,yEAAyE;IACzE,MAAM,eAAe,GAAkB;QACrC,GAAG,EAAE,OAAO,CAAC,YAAY;QACzB,GAAG,EAAE,OAAO,CAAC,YAAY;KAC1B,CAAC;IAEF,OAAO;QACL,UAAU,EAAE,eAAe;QAC3B,iBAAiB,EAAE,YAAY,CAAC,iBAAiB;KAClD,CAAC;AACJ,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,2CAA2C,CACzD,aAAkC;IAElC,OAAO,aAAa,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,+BAA+B,CAAC,OAAO,CAAC,CAAC,CAAC;AAClF,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,kCAAkC,CAAC,eAA8B;IAC/E,OAAO,IAAI,UAAU,CACnB,eAAe,CAAC,GAAG,EACnB,eAAe,CAAC,GAAG,EACnB,IAAI,EAAE,mCAAmC;IACzC,KAAK,CACN,CAAC;AACJ,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { QueryRange } from \"../../routing/QueryRange.js\";\nimport type { QueryRangeMapping } from \"../../queryExecutionContext/queryRangeMapping.js\";\n\n/**\n * @hidden\n */\nexport interface RangeBoundary {\n  /**\n   * Minimum boundary (inclusive)\n   */\n  min: string;\n  /**\n   * Maximum boundary (exclusive)\n   */\n  max: string;\n}\n\n/**\n * @hidden\n * Base interface for all continuation tokens containing common fields\n */\nexport interface BaseContinuationToken {\n  /**\n   * Resource ID of the container for which the continuation token is issued\n   */\n  rid: string;\n\n  /**\n   * List of query ranges with their continuation tokens\n   */\n  rangeMappings: QueryRangeWithContinuationToken[];\n\n  /**\n   * Current offset value for OFFSET/LIMIT queries\n   */\n  offset?: number;\n\n  /**\n   * Current limit value for OFFSET/LIMIT queries\n   */\n  limit?: number;\n}\n\n/**\n * @hidden\n * Composite continuation token for parallel query execution across multiple partition ranges\n */\nexport interface CompositeQueryContinuationToken extends BaseContinuationToken {}\n\n/**\n * Creates a new CompositeQueryContinuationToken\n * @hidden\n */\nexport function createCompositeQueryContinuationToken(\n  rid: string,\n  rangeMappings: QueryRangeWithContinuationToken[],\n  offset?: number,\n  limit?: number,\n): CompositeQueryContinuationToken {\n  if (!rangeMappings || rangeMappings.length === 0) {\n    throw new Error(\n      \"Failed to create composite continuation token: No partition range mappings provided. \" +\n        \"This typically indicates an issue with query execution context initialization or partition key range resolution. \" +\n        \"Ensure the query is properly configured and the container has valid partition ranges.\",\n    );\n  }\n\n  return {\n    rid,\n    rangeMappings: rangeMappings,\n    offset,\n    limit,\n  };\n}\n\n/**\n * Serializes the composite continuation token to a JSON string\n * @hidden\n */\nexport function serializeCompositeToken(token: CompositeQueryContinuationToken): string {\n  return JSON.stringify(token);\n}\n\n/**\n * Deserializes a JSON string to a CompositeQueryContinuationToken\n * @hidden\n */\nexport function parseCompositeQueryContinuationToken(\n  tokenString: string,\n): CompositeQueryContinuationToken {\n  return JSON.parse(tokenString);\n}\n\n/**\n * Deserializes a JSON string to a CompositeQueryContinuationToken\n * @hidden\n */\nexport function parseBaseContinuationToken(tokenString: string): BaseContinuationToken {\n  return JSON.parse(tokenString);\n}\n\n/**\n * @hidden\n * Represents a query range with its associated continuation token\n */\nexport interface QueryRangeWithContinuationToken {\n  /**\n   * The simplified query range containing min/max boundaries\n   */\n  queryRange: RangeBoundary;\n\n  /**\n   * The continuation token for this specific range\n   */\n  continuationToken: string | undefined;\n}\n\n/**\n * Converts QueryRangeMapping to QueryRangeWithContinuationToken using simplified range format\n * @param rangeMapping - The QueryRangeMapping to convert\n * @returns QueryRangeWithContinuationToken with simplified boundaries and continuation token\n * @hidden\n */\nexport function convertRangeMappingToQueryRange(\n  rangeMapping: QueryRangeMapping,\n): QueryRangeWithContinuationToken {\n  if (!rangeMapping.partitionKeyRange) {\n    throw new Error(\n      \"Failed to convert range mapping: Missing partition key range information. \" +\n        \"The QueryRangeMapping object must contain a valid partitionKeyRange with min and max boundaries. \" +\n        \"This may indicate an incomplete partition key range resolution during query setup.\",\n    );\n  }\n\n  const pkRange = rangeMapping.partitionKeyRange;\n\n  // Create simplified range assuming min is inclusive and max is exclusive\n  const simplifiedRange: RangeBoundary = {\n    min: pkRange.minInclusive,\n    max: pkRange.maxExclusive,\n  };\n\n  return {\n    queryRange: simplifiedRange,\n    continuationToken: rangeMapping.continuationToken,\n  };\n}\n\n/**\n * Converts an array of QueryRangeMapping to an array of QueryRangeWithContinuationToken\n * @param rangeMappings - Array of QueryRangeMapping to convert\n * @returns Array of QueryRangeWithContinuationToken with simplified boundaries and continuation tokens\n * @hidden\n */\nexport function convertRangeMappingsToQueryRangesWithTokens(\n  rangeMappings: QueryRangeMapping[],\n): QueryRangeWithContinuationToken[] {\n  return rangeMappings.map((mapping) => convertRangeMappingToQueryRange(mapping));\n}\n\n/**\n * Converts a SimplifiedQueryRange back to a QueryRange for internal use\n * @param simplifiedRange - The simplified range to convert\n * @returns QueryRange with standard assumptions (min inclusive, max exclusive)\n * @hidden\n */\nexport function convertSimplifiedRangeToQueryRange(simplifiedRange: RangeBoundary): QueryRange {\n  return new QueryRange(\n    simplifiedRange.min,\n    simplifiedRange.max,\n    true, // minInclusive = true (assumption)\n    false, // maxInclusive = false (max is exclusive, assumption)\n  );\n}\n"]}