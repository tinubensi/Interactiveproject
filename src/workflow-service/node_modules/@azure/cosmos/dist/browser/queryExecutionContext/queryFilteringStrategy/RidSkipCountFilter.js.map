{"version":3,"file":"RidSkipCountFilter.js","sourceRoot":"","sources":["../../../../src/queryExecutionContext/queryFilteringStrategy/RidSkipCountFilter.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAGlC,OAAO,EAAE,mBAAmB,EAAE,MAAM,yBAAyB,CAAC;AAE9D;;;;;;;;;;;GAWG;AACH,MAAM,OAAO,kBAAkB;IAMA;IALrB,kBAAkB,CAAS;IAEnC;;OAEG;IACH,YAA6B,aAA4B;QAA5B,kBAAa,GAAb,aAAa,CAAe;QACvD,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC;IACzD,CAAC;IAED;;;;OAIG;IACI,WAAW,CAAC,SAAgB;QACjC,MAAM,YAAY,GAAU,EAAE,CAAC;QAC/B,IAAI,YAAY,GAAG,CAAC,CAAC;QAErB,KAAK,MAAM,GAAG,IAAI,SAAS,EAAE,CAAC;YAC5B,IAAI,CAAC,IAAI,CAAC,qBAAqB,CAAC,GAAG,CAAC,EAAE,CAAC;gBACrC,YAAY,EAAE,CAAC;gBACf,SAAS;YACX,CAAC;YACD,YAAY,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACzB,CAAC;QACD,OAAO,YAAY,CAAC;IACtB,CAAC;IAED;;;OAGG;IACK,qBAAqB,CAAC,GAAQ;QACpC,0DAA0D;QAC1D,MAAM,gBAAgB,GAAG,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,CAAC;QAEvD,qCAAqC;QACrC,8FAA8F;QAC9F,sGAAsG;QAEtG,6EAA6E;QAC7E,IAAI,gBAAgB,GAAG,CAAC,EAAE,CAAC;YACzB,OAAO,IAAI,CAAC,CAAC,uDAAuD;QACtE,CAAC;QAED,4EAA4E;QAC5E,IAAI,gBAAgB,GAAG,CAAC,EAAE,CAAC;YACzB,OAAO,KAAK,CAAC,CAAC,qDAAqD;QACrE,CAAC;QAED,sEAAsE;QACtE,qFAAqF;QACrF,iCAAiC;QACjC,mFAAmF;QACnF,+DAA+D;QAC/D,uCAAuC;QACvC,uCAAuC;QACvC,oBAAoB;QACpB,MAAM;QACN,uBAAuB;QACvB,IAAI;QAEJ,wEAAwE;QACxE,4EAA4E;QAC5E,MAAM,MAAM,GAAG,GAAG,CAAC,IAAI,CAAC;QAExB,IAAI,eAAuB,CAAC;QAC5B,IAAI,IAAI,CAAC,aAAa,CAAC,GAAG,KAAK,MAAM,EAAE,CAAC;YACtC,eAAe,GAAG,CAAC,CAAC;QACtB,CAAC;aAAM,CAAC;YACN,oDAAoD;YACpD,MAAM,kBAAkB,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC;YACpE,MAAM,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;YAE3C,IAAI,kBAAkB,GAAG,SAAS,EAAE,CAAC;gBACnC,eAAe,GAAG,CAAC,CAAC,CAAC;YACvB,CAAC;iBAAM,IAAI,kBAAkB,GAAG,SAAS,EAAE,CAAC;gBAC1C,eAAe,GAAG,CAAC,CAAC;YACtB,CAAC;iBAAM,CAAC;gBACN,eAAe,GAAG,CAAC,CAAC;YACtB,CAAC;QACH,CAAC;QACD,qEAAqE;QACrE,MAAM,UAAU,GAAG,IAAI,CAAC,aAAa,CAAC,UAAU,IAAI,EAAE,CAAC;QACvD,MAAM,kBAAkB,GAAG,IAAI,CAAC,aAAa,CAAC,kBAAkB,CAAC;QAEjE,gDAAgD;QAChD,oDAAoD;QACpD,MAAM,iBAAiB,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,KAAK,YAAY,CAAC,CAAC;QAE7E,IAAI,CAAC,kBAAkB,IAAI,kBAAkB,CAAC,iBAAiB,EAAE,CAAC;YAChE,qDAAqD;YACrD,IAAI,iBAAiB,EAAE,CAAC;gBACtB,eAAe,GAAG,CAAC,eAAe,CAAC,CAAC,2BAA2B;YACjE,CAAC;QACH,CAAC;aAAM,CAAC;YACN,wDAAwD;YACxD,IAAI,kBAAkB,CAAC,gBAAgB,EAAE,CAAC;gBACxC,eAAe,GAAG,CAAC,eAAe,CAAC,CAAC,qCAAqC;YAC3E,CAAC;QACH,CAAC;QAED,6CAA6C;QAC7C,IAAI,eAAe,GAAG,CAAC,EAAE,CAAC;YACxB,OAAO,KAAK,CAAC,CAAC,6CAA6C;QAC7D,CAAC;QAED,IAAI,eAAe,GAAG,CAAC,EAAE,CAAC;YACxB,OAAO,IAAI,CAAC,CAAC,iDAAiD;QAChE,CAAC;QAED,kEAAkE;QAClE,IAAI,IAAI,CAAC,kBAAkB,GAAG,CAAC,EAAE,CAAC;YAChC,IAAI,CAAC,kBAAkB,EAAE,CAAC;YAC1B,OAAO,KAAK,CAAC,CAAC,uCAAuC;QACvD,CAAC;QAED,OAAO,IAAI,CAAC,CAAC,+CAA+C;IAC9D,CAAC;IAED;;;;;;;;;OASG;IACK,WAAW,CAAC,GAAW;QAC7B,qBAAqB;QACrB,IAAI,GAAG,KAAK,IAAI,IAAI,GAAG,KAAK,SAAS,EAAE,CAAC;YACtC,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC;QAC9C,CAAC;QACD,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE,CAAC;YAC5B,MAAM,IAAI,KAAK,CAAC,6BAA6B,OAAO,GAAG,EAAE,CAAC,CAAC;QAC7D,CAAC;QACD,IAAI,GAAG,CAAC,IAAI,EAAE,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAC5B,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAC;QACzC,CAAC;QAED,IAAI,CAAC;YACH,MAAM,aAAa,GAAG,GAAG,CAAC,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;YAC7C,MAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,aAAa,EAAE,QAAQ,CAAC,CAAC;YAEnD,yEAAyE;YACzE,IAAI,KAAK,CAAC,MAAM,GAAG,EAAE,EAAE,CAAC;gBACtB,MAAM,IAAI,KAAK,CAAC,kDAAkD,KAAK,CAAC,MAAM,EAAE,CAAC,CAAC;YACpF,CAAC;YAED,uDAAuD;YACvD,2EAA2E;YAC3E,IAAI,MAAM,GAAG,EAAE,CAAC;YAChB,KAAK,IAAI,CAAC,GAAG,EAAE,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;gBAC7B,MAAM,GAAG,CAAC,MAAM,IAAI,EAAE,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,4BAA4B;YACjF,CAAC;YAED,OAAO,MAAM,CAAC;QAChB,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,MAAM,IAAI,KAAK,CACb,0BAA0B,GAAG,gBAAgB,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CACtG,CAAC;QACJ,CAAC;IACH,CAAC;IAED;;;;;OAKG;IACK,mBAAmB,CAAC,GAAQ;QAClC,MAAM,eAAe,GAAG,GAAG,CAAC,YAAY,IAAI,EAAE,CAAC;QAC/C,MAAM,wBAAwB,GAAG,IAAI,CAAC,aAAa,CAAC,YAAY,IAAI,EAAE,CAAC;QACvE,MAAM,UAAU,GAAG,IAAI,CAAC,aAAa,CAAC,UAAU,IAAI,EAAE,CAAC;QAEvD,yDAAyD;QACzD,sFAAsF;QACtF,OAAO,mBAAmB,CAAC,eAAe,EAAE,wBAAwB,EAAE,UAAU,CAAC,CAAC;IACpF,CAAC;CACF","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { FilterContext, FilterStrategy } from \"../index.js\";\nimport { compareOrderByItems } from \"../orderByComparator.js\";\n\n/**\n * Implements post-fetch filtering for ORDER BY queries to handle continuation tokens correctly.\n * This logic is applied only to the target partition from which a query is resumed.\n * It filters out documents that have already been emitted in previous pages by comparing\n * ORDER BY item values first, then document _rid, and finally using skip count for tie-breaking.\n *\n * Follows the .NET SDK FilterNextAsync logic:\n * 1. Compare OrderBy values with continuation token values\n * 2. Skip documents that come before continuation point\n * 3. For exact OrderBy matches, use RID comparison\n * 4. For exact RID matches, apply skip count logic\n */\nexport class RidSkipCountFilter implements FilterStrategy {\n  private remainingSkipCount: number;\n\n  /**\n   * @param filterContext - The context containing values from the continuation token.\n   */\n  constructor(private readonly filterContext: FilterContext) {\n    this.remainingSkipCount = this.filterContext.skipCount;\n  }\n\n  /**\n   * Applies the comprehensive OrderBy + RID + SkipCount filtering logic.\n   * @param documents - The documents fetched from the target partition.\n   * @returns A new array containing only the documents that should be processed.\n   */\n  public applyFilter(documents: any[]): any[] {\n    const filteredDocs: any[] = [];\n    let skippedCount = 0;\n\n    for (const doc of documents) {\n      if (!this.shouldIncludeDocument(doc)) {\n        skippedCount++;\n        continue;\n      }\n      filteredDocs.push(doc);\n    }\n    return filteredDocs;\n  }\n\n  /**\n   * Determines if a document should be included based on OrderBy values, RID, and skip count.\n   * Implements the .NET SDK's FilterNextAsync logic with robust OrderBy comparison.\n   */\n  private shouldIncludeDocument(doc: any): boolean {\n    // Step 1: OrderBy Value Filtering using OrderByComparator\n    const sortOrderCompare = this.compareOrderByItems(doc);\n\n    // FIXED: Correct the inverted logic!\n    // compareOrderByItems returns: negative if doc < continuation, positive if doc > continuation\n    // But for filtering: negative means doc comes BEFORE (skip), positive means doc comes AFTER (include)\n\n    // If sortOrderCompare < 0, this document comes before the continuation point\n    if (sortOrderCompare < 0) {\n      return true; // Include documents that come after continuation point\n    }\n\n    // If sortOrderCompare > 0, this document comes after the continuation point\n    if (sortOrderCompare > 0) {\n      return false; // Skip documents that come before continuation point\n    }\n\n    // Step 2: RID Filtering (sortOrderCompare === 0, same OrderBy values)\n    // Check if RID is available for comparison (some queries like JOIN may not have RID)\n    // if (!this.filterContext.rid) {\n    //    //   // Without RID, we can't do RID-based filtering, so include the document\n    //   // The skipCount logic will handle any necessary filtering\n    //   if (this.remainingSkipCount > 0) {\n    //    //     this.remainingSkipCount--;\n    //     return false;\n    //   }\n    //    //   return true;\n    // }\n\n    // For ORDER BY queries, _rid is at the top level of doc, not in payload\n    // Query rewrites to: SELECT c._rid, [...] AS orderByItems, {...} AS payload\n    const docRid = doc._rid;\n\n    let ridOrderCompare: number;\n    if (this.filterContext.rid === docRid) {\n      ridOrderCompare = 0;\n    } else {\n      // Use BigInt comparison for accurate RID comparison\n      const continuationBigInt = this.ridToBigInt(this.filterContext.rid);\n      const docBigInt = this.ridToBigInt(docRid);\n\n      if (continuationBigInt < docBigInt) {\n        ridOrderCompare = -1;\n      } else if (continuationBigInt > docBigInt) {\n        ridOrderCompare = 1;\n      } else {\n        ridOrderCompare = 0;\n      }\n    }\n    // Apply direction logic based on sort order and query execution info\n    const sortOrders = this.filterContext.sortOrders || [];\n    const queryExecutionInfo = this.filterContext.queryExecutionInfo;\n\n    // Direction logic based on index scan direction\n    // Find the first descending sort order in the array\n    const hasDescendingSort = sortOrders.some((order) => order === \"Descending\");\n\n    if (!queryExecutionInfo || queryExecutionInfo.reverseRidEnabled) {\n      // Default behavior or when reverseRidEnabled is true\n      if (hasDescendingSort) {\n        ridOrderCompare = -ridOrderCompare; // Flip for DESC sort order\n      }\n    } else {\n      // When reverseRidEnabled is false, use reverseIndexScan\n      if (queryExecutionInfo.reverseIndexScan) {\n        ridOrderCompare = -ridOrderCompare; // Flip based on index scan direction\n      }\n    }\n\n    // if (ridOrderCompare > 0) continue; // Skip\n    if (ridOrderCompare > 0) {\n      return false; // Skip documents that were already processed\n    }\n\n    if (ridOrderCompare < 0) {\n      return true; // Include documents that come after continuation\n    }\n\n    // Step 3: SkipCount Logic (ridOrderCompare === 0, exact same RID)\n    if (this.remainingSkipCount > 0) {\n      this.remainingSkipCount--;\n      return false; // Skip this document due to skip count\n    }\n\n    return true; // Include this document (skip count exhausted)\n  }\n\n  /**\n   * Convert RID to BigInt for accurate comparison.\n   * Decodes base64 RID and extracts the Document ID portion (8 bytes at offset 8) as BigInt.\n   *\n   * RID Structure (from Java SDK ResourceId.java):\n   * - Bytes 0-3: Database ID (4 bytes)\n   * - Bytes 4-7: Collection ID (4 bytes)\n   * - Bytes 8-15: Document ID (8 bytes, stored in Big Endian but compared in Little Endian)\n   * - Bytes 16-19: Attachment ID (4 bytes, optional)\n   */\n  private ridToBigInt(rid: string): bigint {\n    // Validate input RID\n    if (rid === null || rid === undefined) {\n      throw new Error(`RID is null or undefined`);\n    }\n    if (typeof rid !== \"string\") {\n      throw new Error(`RID must be a string, got ${typeof rid}`);\n    }\n    if (rid.trim().length === 0) {\n      throw new Error(`RID is empty string`);\n    }\n\n    try {\n      const normalizedRid = rid.replace(/-/g, \"/\");\n      const bytes = Buffer.from(normalizedRid, \"base64\");\n\n      // Validate RID length - must be at least 16 bytes to contain document ID\n      if (bytes.length < 16) {\n        throw new Error(`RID too short: expected at least 16 bytes, got ${bytes.length}`);\n      }\n\n      // Extract Document ID portion (8 bytes at offset 8-15)\n      // The bytes are stored as Big Endian but must be compared as Little Endian\n      let result = 0n;\n      for (let i = 15; i >= 8; i--) {\n        result = (result << 8n) | BigInt(bytes[i] & 0xff); // & 0xFF treats as unsigned\n      }\n\n      return result;\n    } catch (error) {\n      throw new Error(\n        `Failed to convert RID '${rid}' to BigInt: ${error instanceof Error ? error.message : String(error)}`,\n      );\n    }\n  }\n\n  /**\n   * Compares the OrderBy items of a document with the continuation token's OrderBy items.\n   * Uses the exported compareOrderByItems utility function from orderByItemComparator.\n   * @param doc - The document to compare\n   * @returns negative if doc comes before continuation, 0 if same, positive if doc comes after\n   */\n  private compareOrderByItems(doc: any): number {\n    const docOrderByItems = doc.orderByItems || [];\n    const continuationOrderByItems = this.filterContext.orderByItems || [];\n    const sortOrders = this.filterContext.sortOrders || [];\n\n    // Compare doc vs continuation (not continuation vs doc!)\n    // Returns: negative if doc < continuation, 0 if equal, positive if doc > continuation\n    return compareOrderByItems(docOrderByItems, continuationOrderByItems, sortOrders);\n  }\n}\n"]}