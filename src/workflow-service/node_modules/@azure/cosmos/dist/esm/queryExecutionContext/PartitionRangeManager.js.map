{"version":3,"file":"PartitionRangeManager.js","sourceRoot":"","sources":["../../../src/queryExecutionContext/PartitionRangeManager.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { QueryRangeWithContinuationToken } from \"../documents/ContinuationToken/CompositeQueryContinuationToken.js\";\nimport type { QueryRangeMapping } from \"./queryRangeMapping.js\";\n\n/**\n * Manages partition key range mappings for query execution.\n * Handles range operations, offset/limit processing, and distinct query logic.\n * @hidden\n */\nexport class PartitionRangeManager {\n  private partitionKeyRangeMap: Map<string, QueryRangeMapping> = new Map();\n\n  constructor(initialPartitionKeyRangeMap?: Map<string, QueryRangeMapping>) {\n    if (initialPartitionKeyRangeMap) {\n      this.partitionKeyRangeMap = new Map(initialPartitionKeyRangeMap);\n    }\n  }\n\n  /**\n   * Gets a copy of the current partition key range map for constructor pattern\n   */\n  public getPartitionKeyRangeMap(): Map<string, QueryRangeMapping> {\n    return new Map(this.partitionKeyRangeMap);\n  }\n\n  /**\n   * Checks if a continuation token indicates an exhausted partition\n   * @param continuationToken - The continuation token to check\n   * @returns true if the partition is exhausted (null, empty, or \"null\" string)\n   */\n  private isPartitionExhausted(continuationToken: string | undefined): boolean {\n    return (\n      !continuationToken ||\n      continuationToken === \"\" ||\n      continuationToken === \"null\" ||\n      continuationToken.toLowerCase() === \"null\"\n    );\n  }\n\n  /**\n   * Adds a range mapping to the partition key range map\n   * Does not allow updates to existing keys - only new additions\n   * @param rangeId - Unique identifier for the partition range\n   * @param mapping - The QueryRangeMapping to add\n   */\n  private addPartitionRangeMapping(rangeId: string, mapping: QueryRangeMapping): void {\n    if (!this.partitionKeyRangeMap.has(rangeId)) {\n      this.partitionKeyRangeMap.set(rangeId, mapping);\n    }\n  }\n\n  /**\n   * Removes a range mapping from the partition key range map\n   */\n  public removePartitionRangeMapping(rangeId: string): void {\n    this.partitionKeyRangeMap.delete(rangeId);\n  }\n\n  /**\n   * Updates the partition key range map with new mappings from the endpoint response\n   * @param partitionKeyRangeMap - Map of range IDs to QueryRangeMapping objects\n   */\n  public addPartitionKeyRangeMap(partitionKeyRangeMap: Map<string, QueryRangeMapping>): void {\n    if (partitionKeyRangeMap) {\n      for (const [rangeId, mapping] of partitionKeyRangeMap) {\n        this.addPartitionRangeMapping(rangeId, mapping);\n      }\n    }\n  }\n\n  /**\n   * Checks if there are any unprocessed ranges in the sliding window\n   */\n  public hasUnprocessedRanges(): boolean {\n    return this.partitionKeyRangeMap.size > 0;\n  }\n\n  /**\n   * Removes exhausted(fully drained) ranges from the given range mappings\n   * @param rangeMappings - Array of range mappings to filter\n   * @returns Filtered array without exhausted ranges\n   */\n  public removeExhaustedRanges(rangeMappings: QueryRangeMapping[]): QueryRangeMapping[] {\n    if (!rangeMappings || !Array.isArray(rangeMappings)) {\n      return [];\n    }\n\n    return rangeMappings.filter((mapping) => {\n      if (!mapping) {\n        return false;\n      }\n      const isExhausted = this.isPartitionExhausted(mapping.continuationToken);\n\n      if (isExhausted) {\n        return false;\n      }\n      return true;\n    });\n  }\n\n  /**\n   * Processes ranges for ORDER BY queries\n   */\n  public processOrderByRanges(pageSize: number): {\n    endIndex: number;\n    processedRanges: string[];\n    lastRangeBeforePageLimit: QueryRangeMapping | null;\n  } {\n    let endIndex = 0;\n    const processedRanges: string[] = [];\n    let lastRangeBeforePageLimit: QueryRangeMapping | null = null;\n    let rangeIndex = 0;\n    for (const [rangeId, value] of this.partitionKeyRangeMap) {\n      rangeIndex++;\n      const { itemCount } = value;\n      // Check if this complete range fits within remaining page size capacity\n      if (endIndex + itemCount <= pageSize) {\n        lastRangeBeforePageLimit = value;\n        endIndex += itemCount;\n        processedRanges.push(rangeId);\n      } else {\n        break;\n      }\n    }\n\n    return { endIndex, processedRanges, lastRangeBeforePageLimit };\n  }\n\n  public processEmptyOrderByRanges(ranges: QueryRangeWithContinuationToken[]): {\n    endIndex: number;\n    processedRanges: string[];\n    lastRangeBeforePageLimit: QueryRangeMapping | undefined;\n  } {\n    const endIndex = 0;\n    const processedRanges: string[] = [];\n    let lastRangeBeforePageLimit: QueryRangeMapping | undefined;\n\n    // since there is no data returned add all the ids to processed ranges\n    for (const [rangeId, _] of this.partitionKeyRangeMap) {\n      processedRanges.push(rangeId);\n    }\n    // search for matching range in the map(min max value exact match) and return that as lastRangeBeforePageLimit\n    for (const [_, mapping] of this.partitionKeyRangeMap) {\n      if (\n        mapping.partitionKeyRange!.minInclusive === ranges[0].queryRange.min &&\n        mapping.partitionKeyRange!.maxExclusive === ranges[0].queryRange.max\n      ) {\n        lastRangeBeforePageLimit = mapping;\n        break;\n      }\n    }\n\n    return { endIndex, processedRanges, lastRangeBeforePageLimit };\n  }\n  /**\n   * Processes ranges for parallel queries - multi-range aggregation\n   */\n  public processParallelRanges(pageSize: number): {\n    endIndex: number;\n    processedRanges: string[];\n    processedRangeMappings: QueryRangeMapping[];\n    lastPartitionBeforeCutoff?: { rangeId: string; mapping: QueryRangeMapping };\n  } {\n    let endIndex = 0;\n    const processedRanges: string[] = [];\n    const processedRangeMappings: QueryRangeMapping[] = [];\n    let rangesAggregatedInCurrentToken = 0;\n    let lastPartitionBeforeCutoff: { rangeId: string; mapping: QueryRangeMapping } | undefined;\n\n    for (const [rangeId, value] of this.partitionKeyRangeMap) {\n      rangesAggregatedInCurrentToken++;\n\n      // Validate range data\n      if (!value || value.itemCount === undefined) {\n        continue;\n      }\n\n      const { itemCount } = value;\n      if (endIndex + itemCount <= pageSize) {\n        lastPartitionBeforeCutoff = { rangeId, mapping: value };\n        endIndex += itemCount;\n        processedRanges.push(rangeId);\n        processedRangeMappings.push(value);\n      } else {\n        break; // No more ranges can fit, exit loop\n      }\n    }\n\n    return { endIndex, processedRanges, processedRangeMappings, lastPartitionBeforeCutoff };\n  }\n}\n"]}