import type { PartitionKeyRange } from "../../index.js";
import type { TargetPartitionRangeStrategy, PartitionRangeFilterResult } from "./TargetPartitionRangeStrategy.js";
import type { PartitionRangeWithContinuationToken } from "./TargetPartitionRangeManager.js";
/**
 * Strategy for filtering partition ranges in ORDER BY query execution context
 * Supports resuming from continuation tokens with proper range-token pair management
 * @hidden
 */
export declare class OrderByQueryRangeStrategy implements TargetPartitionRangeStrategy {
    getStrategyType(): string;
    filterPartitionRanges(targetRanges: PartitionKeyRange[], continuationRanges?: PartitionRangeWithContinuationToken[], queryInfo?: Record<string, unknown>): PartitionRangeFilterResult;
    /**
     * Creates a filter condition for ranges based on ORDER BY items and sort orders
     * This filter ensures that ranges only return documents based on their position relative to the continuation point
     * @param orderByItems - Array of order by items from the continuation token
     * @param queryInfo - Query information containing sort orders and other metadata
     * @param rangePosition - Whether this is for "left" or "right" ranges relative to continuation point
     * @returns SQL filter condition string for the specified range position
     */
    private createRangeFilterCondition;
    /**
     * Extracts sort orders from query info
     * @throws Error if sort order information is missing or invalid
     */
    private extractSortOrders;
    /**
     * Extracts field path from ORDER BY expressions in query plan
     * @throws Error if orderByExpressions are not found or index is out of bounds or expression format is invalid
     */
    private extractFieldPath;
    /**
     * Creates a comparison condition based on the field, value, sort order, and range position
     */
    private createComparisonCondition;
    /**
     * Formats a value for use in SQL condition
     */
    private formatValueForSQL;
    /**
     * Compares partition key range boundaries with proper handling for inclusive/exclusive semantics
     * @param boundary1 - First boundary to compare
     * @param boundary2 - Second boundary to compare
     * @returns negative if boundary1 is less than boundary2, positive if boundary1 is greater than boundary2, 0 if equal
     */
    private comparePartitionKeyBoundaries;
    private isRangeBeforeAnother;
    private isRangeAfterAnother;
}
//# sourceMappingURL=OrderByQueryRangeStrategy.d.ts.map