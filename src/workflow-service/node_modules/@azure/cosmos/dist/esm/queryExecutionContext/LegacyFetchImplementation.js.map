{"version":3,"file":"LegacyFetchImplementation.js","sourceRoot":"","sources":["../../../src/queryExecutionContext/LegacyFetchImplementation.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAIlC,OAAO,EAAE,YAAY,EAAE,gBAAgB,EAAE,MAAM,kBAAkB,CAAC;AAGlE;;;GAGG;AACH,MAAM,OAAO,yBAAyB;IAE1B;IACA;IAFV,YACU,QAA0B,EAC1B,QAAgB;QADhB,aAAQ,GAAR,QAAQ,CAAkB;QAC1B,aAAQ,GAAR,QAAQ,CAAQ;IACvB,CAAC;IAEJ,KAAK,CAAC,SAAS,CACb,cAAsC,EACtC,WAAkB;QAElB,mDAAmD;QACnD,MAAM,oBAAoB,GAAG,gBAAgB,EAAE,CAAC;QAEhD,IAAI,CAAC;YACH,8DAA8D;YAC9D,OAAO,WAAW,CAAC,MAAM,GAAG,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,CAAC,cAAc,EAAE,EAAE,CAAC;gBAC5E,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,SAAU,CAAC,cAAc,CAAC,CAAC;gBAChE,YAAY,CAAC,oBAAoB,EAAE,QAAQ,CAAC,OAAO,CAAC,CAAC;gBAErD,IACE,CAAC,QAAQ;oBACT,CAAC,QAAQ,CAAC,MAAM;oBAChB,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM;oBACvB,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC,EACnC,CAAC;oBACD,IAAI,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;wBAC3B,MAAM,iBAAiB,GAAG,CAAC,GAAG,WAAW,CAAC,CAAC;wBAC3C,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,uBAAuB;wBAC/C,OAAO,EAAE,MAAM,EAAE,iBAAiB,EAAE,OAAO,EAAE,oBAAoB,EAAE,CAAC;oBACtE,CAAC;yBAAM,CAAC;wBACN,OAAO,EAAE,MAAM,EAAE,SAAS,EAAE,OAAO,EAAE,oBAAoB,EAAE,CAAC;oBAC9D,CAAC;gBACH,CAAC;gBACD,WAAW,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;YAC9C,CAAC;YAED,wCAAwC;YACxC,IAAI,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBAC3B,MAAM,IAAI,GAAG,WAAW,CAAC,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;gBACjD,WAAW,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,wBAAwB;gBAC9D,OAAO,EAAE,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,oBAAoB,EAAE,CAAC;YACzD,CAAC;iBAAM,CAAC;gBACN,OAAO,EAAE,MAAM,EAAE,SAAS,EAAE,OAAO,EAAE,oBAAoB,EAAE,CAAC;YAC9D,CAAC;QACH,CAAC;QAAC,OAAO,GAAQ,EAAE,CAAC;YAClB,YAAY,CAAC,oBAAoB,EAAE,GAAG,CAAC,OAAO,CAAC,CAAC;YAChD,GAAG,CAAC,OAAO,GAAG,oBAAoB,CAAC;YACnC,MAAM,GAAG,CAAC;QACZ,CAAC;IACH,CAAC;CACF","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { Response } from \"../request/index.js\";\nimport type { DiagnosticNodeInternal } from \"../diagnostics/DiagnosticNodeInternal.js\";\nimport { mergeHeaders, getInitialHeader } from \"./headerUtils.js\";\nimport type { ExecutionContext } from \"./ExecutionContext.js\";\n\n/**\n * Legacy fetch implementation for when enableQueryControl is false\n * @hidden\n */\nexport class LegacyFetchImplementation {\n  constructor(\n    private endpoint: ExecutionContext,\n    private pageSize: number,\n  ) {}\n\n  async fetchMore(\n    diagnosticNode: DiagnosticNodeInternal,\n    fetchBuffer: any[],\n  ): Promise<Response<any>> {\n    // Initialize headers fresh for each fetchMore call\n    const fetchMoreRespHeaders = getInitialHeader();\n\n    try {\n      // Keep fetching until we have enough items or no more results\n      while (fetchBuffer.length < this.pageSize && this.endpoint.hasMoreResults()) {\n        const response = await this.endpoint.fetchMore!(diagnosticNode);\n        mergeHeaders(fetchMoreRespHeaders, response.headers);\n\n        if (\n          !response ||\n          !response.result ||\n          !response.result.buffer ||\n          response.result.buffer.length === 0\n        ) {\n          if (fetchBuffer.length > 0) {\n            const copiedFetchBuffer = [...fetchBuffer];\n            fetchBuffer.length = 0; // Clear array in place\n            return { result: copiedFetchBuffer, headers: fetchMoreRespHeaders };\n          } else {\n            return { result: undefined, headers: fetchMoreRespHeaders };\n          }\n        }\n        fetchBuffer.push(...response.result.buffer);\n      }\n\n      // Return collected items up to pageSize\n      if (fetchBuffer.length > 0) {\n        const temp = fetchBuffer.slice(0, this.pageSize);\n        fetchBuffer.splice(0, this.pageSize); // Remove items in place\n        return { result: temp, headers: fetchMoreRespHeaders };\n      } else {\n        return { result: undefined, headers: fetchMoreRespHeaders };\n      }\n    } catch (err: any) {\n      mergeHeaders(fetchMoreRespHeaders, err.headers);\n      err.headers = fetchMoreRespHeaders;\n      throw err;\n    }\n  }\n}\n"]}