{"version":3,"file":"parallelQueryExecutionContext.js","sourceRoot":"","sources":["../../../src/queryExecutionContext/parallelQueryExecutionContext.ts"],"names":[],"mappings":";AAAA,uCAAuC;AACvC,kCAAkC;;;AAOlC,iGAA2F;AAI3F,4GAAsG;AACtG,qHAA+G;AAE/G;;;;GAIG;AACH,MAAa,6BACX,SAAQ,wEAAiC;IAGzC,YACE,aAA4B,EAC5B,cAAsB,EACtB,KAA4B,EAC5B,OAAoB,EACpB,6BAA4D,EAC5D,oBAA4B;QAE5B,MAAM,YAAY,GAAG,4DAA2B,CAAC,sBAAsB,CAAC;YACtE,SAAS,EAAE,6BAA6B;SACzC,CAAC,CAAC;QAEH,4CAA4C;QAC5C,MAAM,kBAAkB,GAAG,IAAI,oEAA+B,EAAE,CAAC;QAEjE,2CAA2C;QAC3C,MAAM,UAAU,GAAG,6BAA6B,CAAC,gCAAgC,EAAE,CAAC;QAEpF,oCAAoC;QACpC,KAAK,CACH,aAAa,EACb,cAAc,EACd,KAAK,EACL,OAAO,EACP,6BAA6B,EAC7B,oBAAoB,EACpB,YAAY,EACZ,kBAAkB,EAClB,UAAU,CACX,CAAC;IACJ,CAAC;IAED;;OAEG;IACO,KAAK,CAAC,iBAAiB,CAAC,QAA0B;QAC1D,OAAO,QAAQ,CAAC,kBAAkB,EAAE,CAAC;IACvC,CAAC;IAED;;;;;OAKG;IACO,8BAA8B,CAAC,qBAA8B;QACrE,OAAO,IAAI,CAAC,CAAC,iDAAiD;IAChE,CAAC;IAED;;;;OAIG;IACK,MAAM,CAAC,gCAAgC;QAI7C,OAAO,CAAC,QAA0B,EAAE,QAA0B,EAAU,EAAE;YACxE,MAAM,aAAa,GAAG,QAAQ,CAAC,uBAAuB,CAAC,YAAY,CAAC;YACpE,MAAM,aAAa,GAAG,QAAQ,CAAC,uBAAuB,CAAC,YAAY,CAAC;YAEpE,mEAAmE;YACnE,IAAI,aAAa,KAAK,aAAa,EAAE,CAAC;gBACpC,yEAAyE;gBACzE,MAAM,OAAO,GAAG,QAAQ,CAAC,QAAQ,CAAC;gBAClC,MAAM,OAAO,GAAG,QAAQ,CAAC,QAAQ,CAAC;gBAClC,IAAI,OAAO,IAAI,OAAO,EAAE,CAAC;oBACvB,OAAO,OAAO,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACpC,CAAC;gBACD,OAAO,CAAC,CAAC;YACX,CAAC;YACD,IAAI,aAAa,KAAK,EAAE;gBAAE,OAAO,CAAC,CAAC,CAAC;YACpC,IAAI,aAAa,KAAK,EAAE;gBAAE,OAAO,CAAC,CAAC;YACnC,OAAO,aAAa,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAChD,CAAC,CAAC;IACJ,CAAC;CACF;AAjFD,sEAiFC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { ClientContext } from \"../ClientContext.js\";\nimport type { PartitionedQueryExecutionInfo } from \"../request/ErrorResponse.js\";\nimport type { FeedOptions } from \"../request/FeedOptions.js\";\nimport type { DocumentProducer } from \"./documentProducer.js\";\nimport type { ExecutionContext } from \"./ExecutionContext.js\";\nimport { ParallelQueryExecutionContextBase } from \"./parallelQueryExecutionContextBase.js\";\nimport type { Response } from \"../request/index.js\";\nimport type { SqlQuerySpec } from \"./SqlQuerySpec.js\";\n\nimport { TargetPartitionRangeManager } from \"./queryFilteringStrategy/TargetPartitionRangeManager.js\";\nimport { ParallelQueryProcessingStrategy } from \"./queryProcessingStrategy/ParallelQueryProcessingStrategy.js\";\n\n/**\n * Provides the ParallelQueryExecutionContext.\n * This class is capable of handling parallelized queries and derives from ParallelQueryExecutionContextBase.\n * @hidden\n */\nexport class ParallelQueryExecutionContext\n  extends ParallelQueryExecutionContextBase\n  implements ExecutionContext\n{\n  constructor(\n    clientContext: ClientContext,\n    collectionLink: string,\n    query: string | SqlQuerySpec,\n    options: FeedOptions,\n    partitionedQueryExecutionInfo: PartitionedQueryExecutionInfo,\n    correlatedActivityId: string,\n  ) {\n    const rangeManager = TargetPartitionRangeManager.createForParallelQuery({\n      queryInfo: partitionedQueryExecutionInfo,\n    });\n\n    // Create parallel query processing strategy\n    const processingStrategy = new ParallelQueryProcessingStrategy();\n\n    // Create comparator for document producers\n    const comparator = ParallelQueryExecutionContext.createDocumentProducerComparator();\n\n    // Calling on base class constructor\n    super(\n      clientContext,\n      collectionLink,\n      query,\n      options,\n      partitionedQueryExecutionInfo,\n      correlatedActivityId,\n      rangeManager,\n      processingStrategy,\n      comparator,\n    );\n  }\n\n  /**\n   * Fetches all buffered items from producer for parallel processing.\n   */\n  protected async fetchFromProducer(producer: DocumentProducer): Promise<Response<any>> {\n    return producer.fetchBufferedItems();\n  }\n\n  /**\n   * Determines if buffered producers should continue to be processed for parallel queries.\n   * For parallel queries, we process all buffered producers.\n   * @param _isUnfilledQueueEmpty - Whether the unfilled queue is empty (ignored for parallel queries)\n   * @hidden\n   */\n  protected shouldProcessBufferedProducers(_isUnfilledQueueEmpty: boolean): boolean {\n    return true; // Process all buffered items in parallel queries\n  }\n\n  /**\n   * Creates a comparator function for sorting document producers in parallel queries.\n   * Sorts by partition key range minInclusive values, with empty string first,\n   * then lexicographically. Uses EPK ranges as secondary sort when minInclusive values are identical.\n   */\n  private static createDocumentProducerComparator(): (\n    docProd1: DocumentProducer,\n    docProd2: DocumentProducer,\n  ) => number {\n    return (docProd1: DocumentProducer, docProd2: DocumentProducer): number => {\n      const aMinInclusive = docProd1.targetPartitionKeyRange.minInclusive;\n      const bMinInclusive = docProd2.targetPartitionKeyRange.minInclusive;\n\n      // Sort empty string first, then lexicographically (original logic)\n      if (aMinInclusive === bMinInclusive) {\n        // If minInclusive values are the same, check minEPK ranges if they exist\n        const aMinEpk = docProd1.startEpk;\n        const bMinEpk = docProd2.startEpk;\n        if (aMinEpk && bMinEpk) {\n          return aMinEpk < bMinEpk ? -1 : 1;\n        }\n        return 0;\n      }\n      if (aMinInclusive === \"\") return -1;\n      if (bMinInclusive === \"\") return 1;\n      return aMinInclusive < bMinInclusive ? -1 : 1;\n    };\n  }\n}\n"]}