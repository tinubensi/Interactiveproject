"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.TargetPartitionRangeManager = exports.QueryExecutionContextType = void 0;
const ParallelQueryRangeStrategy_js_1 = require("./ParallelQueryRangeStrategy.js");
const OrderByQueryRangeStrategy_js_1 = require("./OrderByQueryRangeStrategy.js");
/**
 * Query execution context types
 * @hidden
 */
var QueryExecutionContextType;
(function (QueryExecutionContextType) {
    QueryExecutionContextType["Parallel"] = "Parallel";
    QueryExecutionContextType["OrderBy"] = "OrderBy";
})(QueryExecutionContextType || (exports.QueryExecutionContextType = QueryExecutionContextType = {}));
/**
 * Manager class responsible for filtering target partition ranges based on query type and continuation tokens.
 * Uses the Strategy pattern to provide different filtering logic for different query types.
 * @hidden
 */
class TargetPartitionRangeManager {
    strategy;
    config;
    constructor(config) {
        this.config = config;
        this.strategy = this.createStrategy(config);
    }
    /**
     * Creates the appropriate strategy based on configuration
     */
    createStrategy(config) {
        // Use custom strategy if provided
        if (config.customStrategy) {
            return config.customStrategy;
        }
        // Create default strategy based on query type
        switch (config.queryType) {
            case QueryExecutionContextType.Parallel:
                return new ParallelQueryRangeStrategy_js_1.ParallelQueryRangeStrategy();
            case QueryExecutionContextType.OrderBy:
                return new OrderByQueryRangeStrategy_js_1.OrderByQueryRangeStrategy();
            default:
                throw new Error(`Unsupported query execution context type: ${config.queryType}`);
        }
    }
    /**
     * Filters target partition ranges based on range-token pairs from partition split/merge detection
     * @param targetRanges - All available target partition ranges (fallback if no range-token pairs)
     * @param rangeTokenPairs - Pre-processed range-token pairs after split/merge detection
     * @param additionalQueryInfo - Additional query information to merge with existing queryInfo
     * @returns Filtered partition ranges and metadata
     */
    filterPartitionRanges(targetRanges, rangeTokenPairs, additionalQueryInfo) {
        // Validate inputs
        if (!targetRanges || targetRanges.length === 0) {
            return { rangeTokenPairs: [] };
        }
        // Merge base queryInfo with additional queryInfo (additional takes precedence)
        const mergedQueryInfo = { ...this.config.queryInfo, ...additionalQueryInfo };
        const result = this.strategy.filterPartitionRanges(targetRanges, rangeTokenPairs, mergedQueryInfo);
        return result;
    }
    /**
     * Gets the current strategy type
     */
    getStrategyType() {
        return this.strategy.getStrategyType();
    }
    /**
     * Updates the strategy (useful for switching between query types)
     */
    updateStrategy(newConfig) {
        this.config = newConfig;
        this.strategy = this.createStrategy(newConfig);
    }
    /**
     * Static factory method to create a manager for parallel queries
     */
    static createForParallelQuery(queryInfo) {
        return new TargetPartitionRangeManager({
            queryType: QueryExecutionContextType.Parallel,
            queryInfo,
        });
    }
    /**
     * Static factory method to create a manager for ORDER BY queries
     */
    static createForOrderByQuery(queryInfo) {
        return new TargetPartitionRangeManager({
            queryType: QueryExecutionContextType.OrderBy,
            queryInfo,
        });
    }
}
exports.TargetPartitionRangeManager = TargetPartitionRangeManager;
//# sourceMappingURL=TargetPartitionRangeManager.js.map