{"version":3,"file":"ParallelQueryRangeStrategy.js","sourceRoot":"","sources":["../../../../src/queryExecutionContext/queryFilteringStrategy/ParallelQueryRangeStrategy.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { PartitionKeyRange } from \"../../index.js\";\nimport type {\n  TargetPartitionRangeStrategy,\n  PartitionRangeFilterResult,\n} from \"./TargetPartitionRangeStrategy.js\";\nimport type { PartitionRangeWithContinuationToken } from \"./TargetPartitionRangeManager.js\";\n\n/**\n * Strategy for filtering partition ranges in parallel query execution context\n * Supports resuming from composite continuation tokens with multi-range aggregation\n * @hidden\n */\nexport class ParallelQueryRangeStrategy implements TargetPartitionRangeStrategy {\n  getStrategyType(): string {\n    return \"ParallelQuery\";\n  }\n\n  validateContinuationToken(continuationToken: string): boolean {\n    // Check for null, undefined, or empty string inputs\n    if (!continuationToken) {\n      return false;\n    }\n\n    try {\n      const parsed = JSON.parse(continuationToken);\n      // Check if it's a composite continuation token (has rangeMappings)\n      if (!parsed || !Array.isArray(parsed.rangeMappings)) {\n        return false;\n      }\n\n      // Validate each range mapping has a non-null partitionKeyRange\n      for (const rangeMapping of parsed.rangeMappings) {\n        if (!rangeMapping || !rangeMapping.partitionKeyRange) {\n          return false;\n        }\n      }\n\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  filterPartitionRanges(\n    targetRanges: PartitionKeyRange[],\n    continuationRanges?: PartitionRangeWithContinuationToken[],\n  ): PartitionRangeFilterResult {\n    if (!targetRanges || targetRanges.length === 0) {\n      return { rangeTokenPairs: [] };\n    }\n\n    // If no continuation ranges, return all ranges as range-token pairs\n    if (!continuationRanges || continuationRanges.length === 0) {\n      const rangeTokenPairs = targetRanges.map((range) => ({\n        range,\n        continuationToken: undefined as string | undefined,\n        filteringCondition: undefined as string | undefined,\n      }));\n      return { rangeTokenPairs };\n    }\n\n    const rangeTokenPairs: PartitionRangeWithContinuationToken[] = [];\n    let lastProcessedRange: PartitionKeyRange | null = null;\n\n    // sort continuationRanges in ascending order using their minInclusive values\n    continuationRanges.sort((a, b) => {\n      return a.range.minInclusive.localeCompare(b.range.minInclusive);\n    });\n\n    for (const range of continuationRanges) {\n      // Always track the last processed range, even if it's exhausted\n      lastProcessedRange = range.range;\n\n      if (range && !this.isPartitionExhausted(range.continuationToken)) {\n        rangeTokenPairs.push({\n          range: range.range,\n          continuationToken: range.continuationToken,\n          filteringCondition: range.filteringCondition,\n        });\n      }\n    }\n\n    // Add any new target ranges that come after the last processed range\n    if (lastProcessedRange) {\n      for (const targetRange of targetRanges) {\n        // Only include ranges whose minInclusive value is greater than or equal to maxExclusive of lastProcessedRange\n        if (targetRange.minInclusive >= lastProcessedRange.maxExclusive) {\n          rangeTokenPairs.push({\n            range: targetRange,\n            continuationToken: undefined as string | undefined,\n            filteringCondition: undefined as string | undefined,\n          });\n        }\n      }\n    } else {\n      // If no ranges were processed from continuation token, add all target ranges\n      for (const targetRange of targetRanges) {\n        rangeTokenPairs.push({\n          range: targetRange,\n          continuationToken: undefined as string | undefined,\n          filteringCondition: undefined as string | undefined,\n        });\n      }\n    }\n\n    return {\n      rangeTokenPairs,\n    };\n  }\n\n  /**\n   * Checks if a partition is exhausted based on its continuation token\n   */\n  private isPartitionExhausted(continuationToken: string | undefined): boolean {\n    return (\n      !continuationToken ||\n      continuationToken === \"\" ||\n      continuationToken === \"null\" ||\n      continuationToken.toLowerCase() === \"null\"\n    );\n  }\n}\n"]}