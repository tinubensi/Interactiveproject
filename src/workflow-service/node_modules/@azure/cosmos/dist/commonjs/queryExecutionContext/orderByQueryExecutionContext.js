"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrderByQueryExecutionContext = void 0;
const orderByDocumentProducerComparator_js_1 = require("./orderByDocumentProducerComparator.js");
const parallelQueryExecutionContextBase_js_1 = require("./parallelQueryExecutionContextBase.js");
const TargetPartitionRangeManager_js_1 = require("./queryFilteringStrategy/TargetPartitionRangeManager.js");
const OrderByQueryProcessingStrategy_js_1 = require("./queryProcessingStrategy/OrderByQueryProcessingStrategy.js");
/** @hidden */
class OrderByQueryExecutionContext extends parallelQueryExecutionContextBase_js_1.ParallelQueryExecutionContextBase {
    /**
     * Provides the OrderByQueryExecutionContext.
     * This class is capable of handling orderby queries and dervives from ParallelQueryExecutionContextBase.
     *
     * When handling a parallelized query, it instantiates one instance of
     * DocumentProcuder per target partition key range and aggregates the result of each.
     *
     * @param clientContext - The service endpoint to use to create the client.
     * @param collectionLink - The Collection Link
     * @param options - Represents the feed options.
     * @param partitionedQueryExecutionInfo - PartitionedQueryExecutionInfo
     * @hidden
     */
    constructor(clientContext, collectionLink, query, options, partitionedQueryExecutionInfo, correlatedActivityId) {
        const rangeManager = TargetPartitionRangeManager_js_1.TargetPartitionRangeManager.createForOrderByQuery({
            queryInfo: partitionedQueryExecutionInfo,
        });
        // Create ORDER BY query processing strategy with sortOrders
        const processingStrategy = new OrderByQueryProcessingStrategy_js_1.OrderByQueryProcessingStrategy(partitionedQueryExecutionInfo.queryInfo.orderBy);
        // Create ORDER BY comparator (need to access sortOrders from partitionedQueryExecutionInfo)
        const orderByComparator = new orderByDocumentProducerComparator_js_1.OrderByDocumentProducerComparator(partitionedQueryExecutionInfo.queryInfo.orderBy);
        // Create comparator function for ORDER BY queries
        const comparator = (docProd1, docProd2) => {
            return orderByComparator.compare(docProd1, docProd2);
        };
        // Calling on base class constructor
        super(clientContext, collectionLink, query, options, partitionedQueryExecutionInfo, correlatedActivityId, rangeManager, processingStrategy, comparator);
    }
    /**
     * Fetches next single item from producer for ORDER BY processing.
     */
    async fetchFromProducer(producer) {
        const response = await producer.fetchNextItem();
        if (response && response.result) {
            return {
                result: [response.result],
                headers: response.headers,
            };
        }
        return response;
    }
    /**
     * Determines if buffered producers should continue to be processed for ORDER BY queries.
     * For ORDER BY, only process when no unfilled producers remain to maintain order.
     * @param isUnfilledQueueEmpty - Whether the unfilled queue is empty
     * @hidden
     */
    shouldProcessBufferedProducers(isUnfilledQueueEmpty) {
        // For ORDER BY, only process when no unfilled producers remain to maintain order
        return isUnfilledQueueEmpty;
    }
}
exports.OrderByQueryExecutionContext = OrderByQueryExecutionContext;
//# sourceMappingURL=orderByQueryExecutionContext.js.map