{"version":3,"file":"OrderByEndpointComponent.js","sourceRoot":"","sources":["../../../../src/queryExecutionContext/EndpointComponent/OrderByEndpointComponent.ts"],"names":[],"mappings":";;;AAMA,sEAAsE;AAGtE,cAAc;AACd,MAAa,wBAAwB;IAUzB;IACA;IAVV;;;;;;;OAOG;IACH,YACU,gBAAkC,EAClC,wBAAiC,KAAK;QADtC,qBAAgB,GAAhB,gBAAgB,CAAkB;QAClC,0BAAqB,GAArB,qBAAqB,CAAiB;IAC7C,CAAC;IACJ;;;OAGG;IACI,cAAc;QACnB,OAAO,IAAI,CAAC,gBAAgB,CAAC,cAAc,EAAE,CAAC;IAChD,CAAC;IAEM,KAAK,CAAC,SAAS,CAAC,cAAuC;QAC5D,MAAM,MAAM,GAAU,EAAE,CAAC;QACzB,MAAM,iBAAiB,GAAyB,EAAE,CAAC,CAAC,qCAAqC;QAEzF,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC;QACvE,IACE,CAAC,QAAQ;YACT,CAAC,QAAQ,CAAC,MAAM;YAChB,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC;YACtC,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC,EACnC,CAAC;YACD,6FAA6F;YAC7F,gFAAgF;YAChF,MAAM,cAAc,GAAG,QAAQ,EAAE,MAA6B,CAAC;YAC/D,MAAM,MAAM,GAAG,IAAA,kDAAyB,EACtC,EAAE,EACF,cAAc,EAAE,oBAAoB,IAAI,IAAI,GAAG,EAAE,EACjD,cAAc,EAAE,yBAAyB,IAAI,EAAE,EAC/C,EAAE,CACH,CAAC;YACF,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,OAAO,EAAE,CAAC;QAChD,CAAC;QAED,MAAM,cAAc,GAAG,QAAQ,CAAC,MAA6B,CAAC;QAC9D,MAAM,SAAS,GAAG,cAAc,CAAC,MAAM,CAAC;QACxC,MAAM,oBAAoB,GAAG,cAAc,CAAC,oBAAoB,CAAC;QACjE,MAAM,yBAAyB,GAAG,cAAc,CAAC,yBAAyB,CAAC;QAE3E,gEAAgE;QAChE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAC1C,MAAM,IAAI,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;YAC1B,IAAI,IAAI,CAAC,qBAAqB,EAAE,CAAC;gBAC/B,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACpB,CAAC;iBAAM,CAAC;gBACN,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YAC5B,CAAC;YACD,iBAAiB,CAAC,IAAI,CAAC,EAAE,YAAY,EAAE,IAAI,CAAC,YAAY,EAAE,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;QAC/E,CAAC;QAED,MAAM,MAAM,GAAG,IAAA,kDAAyB,EACtC,MAAM,EACN,oBAAoB,EACpB,yBAAyB,EACzB,iBAAiB,CAClB,CAAC;QAEF,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,QAAQ,CAAC,OAAO,EAAE,CAAC;IAC/C,CAAC;CACF;AArED,4DAqEC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { DiagnosticNodeInternal } from \"../../diagnostics/DiagnosticNodeInternal.js\";\nimport type { Response } from \"../../request/index.js\";\nimport type { ExecutionContext } from \"../ExecutionContext.js\";\nimport type { ParallelQueryResult } from \"../parallelQueryResult.js\";\nimport { createParallelQueryResult } from \"../parallelQueryResult.js\";\nimport type { OrderByItemWithRid } from \"../parallelQueryResult.js\";\n\n/** @hidden */\nexport class OrderByEndpointComponent implements ExecutionContext {\n  /**\n   * Represents an endpoint in handling an order by query. For each processed orderby\n   * result it returns 'payload' item of the result\n   *\n   * @param executionContext - Underlying Execution Context\n   * @param emitRawOrderByPayload - Whether to emit raw order by payload\n   * @hidden\n   */\n  constructor(\n    private executionContext: ExecutionContext,\n    private emitRawOrderByPayload: boolean = false,\n  ) {}\n  /**\n   * Determine if there are still remaining resources to processs.\n   * @returns true if there is other elements to process in the OrderByEndpointComponent.\n   */\n  public hasMoreResults(): boolean {\n    return this.executionContext.hasMoreResults();\n  }\n\n  public async fetchMore(diagnosticNode?: DiagnosticNodeInternal): Promise<Response<any>> {\n    const buffer: any[] = [];\n    const orderByItemsArray: OrderByItemWithRid[] = []; // Store order by items for each item\n\n    const response = await this.executionContext.fetchMore(diagnosticNode);\n    if (\n      !response ||\n      !response.result ||\n      !Array.isArray(response.result.buffer) ||\n      response.result.buffer.length === 0\n    ) {\n      // Preserve the partitionKeyRangeMap and updatedContinuationRanges from the original response\n      // even when the buffer is empty, as they contain continuation token information\n      const originalResult = response?.result as ParallelQueryResult;\n      const result = createParallelQueryResult(\n        [],\n        originalResult?.partitionKeyRangeMap || new Map(),\n        originalResult?.updatedContinuationRanges || {},\n        [],\n      );\n      return { result, headers: response?.headers };\n    }\n\n    const parallelResult = response.result as ParallelQueryResult;\n    const rawBuffer = parallelResult.buffer;\n    const partitionKeyRangeMap = parallelResult.partitionKeyRangeMap;\n    const updatedContinuationRanges = parallelResult.updatedContinuationRanges;\n\n    // Process buffer items and collect order by items for each item\n    for (let i = 0; i < rawBuffer.length; i++) {\n      const item = rawBuffer[i];\n      if (this.emitRawOrderByPayload) {\n        buffer.push(item);\n      } else {\n        buffer.push(item.payload);\n      }\n      orderByItemsArray.push({ orderByItems: item.orderByItems, _rid: item._rid });\n    }\n\n    const result = createParallelQueryResult(\n      buffer,\n      partitionKeyRangeMap,\n      updatedContinuationRanges,\n      orderByItemsArray,\n    );\n\n    return { result, headers: response.headers };\n  }\n}\n"]}