import { QueryRangeWithContinuationToken } from "../documents/ContinuationToken/CompositeQueryContinuationToken.js";
import type { QueryRangeMapping } from "./queryRangeMapping.js";
/**
 * Manages partition key range mappings for query execution.
 * Handles range operations, offset/limit processing, and distinct query logic.
 * @hidden
 */
export declare class PartitionRangeManager {
    private partitionKeyRangeMap;
    constructor(initialPartitionKeyRangeMap?: Map<string, QueryRangeMapping>);
    /**
     * Gets a copy of the current partition key range map for constructor pattern
     */
    getPartitionKeyRangeMap(): Map<string, QueryRangeMapping>;
    /**
     * Checks if a continuation token indicates an exhausted partition
     * @param continuationToken - The continuation token to check
     * @returns true if the partition is exhausted (null, empty, or "null" string)
     */
    private isPartitionExhausted;
    /**
     * Adds a range mapping to the partition key range map
     * Does not allow updates to existing keys - only new additions
     * @param rangeId - Unique identifier for the partition range
     * @param mapping - The QueryRangeMapping to add
     */
    private addPartitionRangeMapping;
    /**
     * Removes a range mapping from the partition key range map
     */
    removePartitionRangeMapping(rangeId: string): void;
    /**
     * Updates the partition key range map with new mappings from the endpoint response
     * @param partitionKeyRangeMap - Map of range IDs to QueryRangeMapping objects
     */
    addPartitionKeyRangeMap(partitionKeyRangeMap: Map<string, QueryRangeMapping>): void;
    /**
     * Checks if there are any unprocessed ranges in the sliding window
     */
    hasUnprocessedRanges(): boolean;
    /**
     * Removes exhausted(fully drained) ranges from the given range mappings
     * @param rangeMappings - Array of range mappings to filter
     * @returns Filtered array without exhausted ranges
     */
    removeExhaustedRanges(rangeMappings: QueryRangeMapping[]): QueryRangeMapping[];
    /**
     * Processes ranges for ORDER BY queries
     */
    processOrderByRanges(pageSize: number): {
        endIndex: number;
        processedRanges: string[];
        lastRangeBeforePageLimit: QueryRangeMapping | null;
    };
    processEmptyOrderByRanges(ranges: QueryRangeWithContinuationToken[]): {
        endIndex: number;
        processedRanges: string[];
        lastRangeBeforePageLimit: QueryRangeMapping | undefined;
    };
    /**
     * Processes ranges for parallel queries - multi-range aggregation
     */
    processParallelRanges(pageSize: number): {
        endIndex: number;
        processedRanges: string[];
        processedRangeMappings: QueryRangeMapping[];
        lastPartitionBeforeCutoff?: {
            rangeId: string;
            mapping: QueryRangeMapping;
        };
    };
}
//# sourceMappingURL=PartitionRangeManager.d.ts.map