{"version":3,"file":"QueryControlFetchImplementation.js","sourceRoot":"","sources":["../../../src/queryExecutionContext/QueryControlFetchImplementation.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { Response } from \"../request/index.js\";\nimport type { DiagnosticNodeInternal } from \"../diagnostics/DiagnosticNodeInternal.js\";\nimport { mergeHeaders, getInitialHeader } from \"./headerUtils.js\";\nimport type { BaseContinuationTokenManager } from \"./ContinuationTokenManager/BaseContinuationTokenManager.js\";\nimport { ContinuationTokenManagerFactory } from \"./ContinuationTokenManager/ContinuationTokenManagerFactory.js\";\nimport { Constants } from \"../common/index.js\";\nimport type { ExecutionContext } from \"./ExecutionContext.js\";\n\n/**\n * Query control enabled fetch implementation with continuation token support\n * @hidden\n */\nexport class QueryControlFetchImplementation {\n  // Required fields for query control - not optional\n  private readonly continuationTokenManager: BaseContinuationTokenManager;\n  private readonly querySupportsTokens: boolean;\n\n  constructor(\n    private endpoint: ExecutionContext,\n    private pageSize: number,\n    collectionLink: string,\n    continuationToken: string | undefined,\n    isOrderByQuery: boolean,\n    querySupportsTokens: boolean,\n  ) {\n    this.querySupportsTokens = querySupportsTokens;\n\n    // Initialize continuation token manager immediately for query control\n    this.continuationTokenManager = ContinuationTokenManagerFactory.create(\n      collectionLink,\n      continuationToken,\n      isOrderByQuery,\n    );\n  }\n\n  async fetchMore(\n    diagnosticNode: DiagnosticNodeInternal,\n    fetchBuffer: any[],\n  ): Promise<Response<any>> {\n    // Initialize headers fresh for each fetchMore call\n    const fetchMoreRespHeaders = getInitialHeader();\n\n    // Use continuation token logic for supported queries when query control is enabled\n    // Otherwise use simplified buffer-only logic\n    if (this.querySupportsTokens) {\n      return this._handleQueryFetch(diagnosticNode, fetchBuffer, fetchMoreRespHeaders);\n    } else {\n      return this._handleSimpleBufferFetch(diagnosticNode, fetchBuffer, fetchMoreRespHeaders);\n    }\n  }\n\n  private async _handleSimpleBufferFetch(\n    diagnosticNode: DiagnosticNodeInternal,\n    fetchBuffer: any[],\n    fetchMoreRespHeaders: Record<string, any>,\n  ): Promise<Response<any>> {\n    // Return buffered data if available\n    if (fetchBuffer.length > 0) {\n      const temp = fetchBuffer.slice(0, this.pageSize);\n      fetchBuffer.splice(0, this.pageSize); // Remove items in place\n      return { result: temp, headers: fetchMoreRespHeaders };\n    }\n\n    // Fetch new data from endpoint\n    const response = await this.endpoint.fetchMore!(diagnosticNode);\n    mergeHeaders(fetchMoreRespHeaders, response.headers);\n\n    if (!response?.result?.buffer?.length) {\n      return this._createEmptyResult(response?.headers);\n    }\n\n    // Buffer new data and return up to pageSize\n    fetchBuffer.length = 0; // Clear existing items\n    fetchBuffer.push(...response.result.buffer); // Add new items\n    const temp = fetchBuffer.slice(0, this.pageSize);\n    fetchBuffer.splice(0, this.pageSize); // Remove returned items in place\n\n    return { result: temp, headers: fetchMoreRespHeaders };\n  }\n\n  private async _handleQueryFetch(\n    diagnosticNode: DiagnosticNodeInternal,\n    fetchBuffer: any[],\n    fetchMoreRespHeaders: Record<string, any>,\n  ): Promise<Response<any>> {\n    if (fetchBuffer.length > 0) {\n      const { endIndex, continuationToken } = this.continuationTokenManager.paginateResults(\n        this.pageSize,\n        false,\n      );\n      const temp = fetchBuffer.slice(0, endIndex);\n      fetchBuffer.splice(0, endIndex); // Remove returned items in place\n      this._setContinuationTokenInHeaders(continuationToken, fetchMoreRespHeaders);\n\n      return { result: temp, headers: fetchMoreRespHeaders };\n    }\n\n    // Fetch new data from endpoint\n    fetchBuffer.length = 0; // Clear existing items in place\n    const response = await this.endpoint.fetchMore!(diagnosticNode);\n    mergeHeaders(fetchMoreRespHeaders, response.headers);\n\n    if (!response?.result?.buffer || response.result.buffer.length === 0) {\n      const { continuationToken } = this.continuationTokenManager.paginateResults(\n        this.pageSize,\n        true, // isResponseEmpty = true\n        response?.result, // Pass response data for processing\n      );\n      this._setContinuationTokenInHeaders(continuationToken, fetchMoreRespHeaders);\n      return this._createEmptyResult(fetchMoreRespHeaders);\n    }\n\n    fetchBuffer.push(...response.result.buffer); // Add new items to existing buffer\n    const { endIndex, continuationToken } = this.continuationTokenManager.paginateResults(\n      this.pageSize,\n      false, // isResponseEmpty = false\n      response.result, // Pass response data for processing\n    );\n\n    const temp = fetchBuffer.slice(0, endIndex);\n    fetchBuffer.splice(0, endIndex); // Remove returned items in place\n    this._setContinuationTokenInHeaders(continuationToken, fetchMoreRespHeaders);\n\n    return { result: temp, headers: fetchMoreRespHeaders };\n  }\n\n  private _setContinuationTokenInHeaders(\n    continuationToken: string | undefined,\n    fetchMoreRespHeaders: Record<string, any>,\n  ): void {\n    if (continuationToken) {\n      Object.assign(fetchMoreRespHeaders, {\n        [Constants.HttpHeaders.Continuation]: continuationToken,\n      });\n    }\n  }\n\n  private _createEmptyResult(headers?: any): Response<any> {\n    const hdrs = headers || getInitialHeader();\n    return { result: [], headers: hdrs };\n  }\n}\n"]}