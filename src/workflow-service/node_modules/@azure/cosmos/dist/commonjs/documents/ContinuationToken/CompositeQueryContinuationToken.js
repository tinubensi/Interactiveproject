"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCompositeQueryContinuationToken = createCompositeQueryContinuationToken;
exports.serializeCompositeToken = serializeCompositeToken;
exports.parseCompositeQueryContinuationToken = parseCompositeQueryContinuationToken;
exports.parseBaseContinuationToken = parseBaseContinuationToken;
exports.convertRangeMappingToQueryRange = convertRangeMappingToQueryRange;
exports.convertRangeMappingsToQueryRangesWithTokens = convertRangeMappingsToQueryRangesWithTokens;
exports.convertSimplifiedRangeToQueryRange = convertSimplifiedRangeToQueryRange;
const QueryRange_js_1 = require("../../routing/QueryRange.js");
/**
 * Creates a new CompositeQueryContinuationToken
 * @hidden
 */
function createCompositeQueryContinuationToken(rid, rangeMappings, offset, limit) {
    if (!rangeMappings || rangeMappings.length === 0) {
        throw new Error("Failed to create composite continuation token: No partition range mappings provided. " +
            "This typically indicates an issue with query execution context initialization or partition key range resolution. " +
            "Ensure the query is properly configured and the container has valid partition ranges.");
    }
    return {
        rid,
        rangeMappings: rangeMappings,
        offset,
        limit,
    };
}
/**
 * Serializes the composite continuation token to a JSON string
 * @hidden
 */
function serializeCompositeToken(token) {
    return JSON.stringify(token);
}
/**
 * Deserializes a JSON string to a CompositeQueryContinuationToken
 * @hidden
 */
function parseCompositeQueryContinuationToken(tokenString) {
    return JSON.parse(tokenString);
}
/**
 * Deserializes a JSON string to a CompositeQueryContinuationToken
 * @hidden
 */
function parseBaseContinuationToken(tokenString) {
    return JSON.parse(tokenString);
}
/**
 * Converts QueryRangeMapping to QueryRangeWithContinuationToken using simplified range format
 * @param rangeMapping - The QueryRangeMapping to convert
 * @returns QueryRangeWithContinuationToken with simplified boundaries and continuation token
 * @hidden
 */
function convertRangeMappingToQueryRange(rangeMapping) {
    if (!rangeMapping.partitionKeyRange) {
        throw new Error("Failed to convert range mapping: Missing partition key range information. " +
            "The QueryRangeMapping object must contain a valid partitionKeyRange with min and max boundaries. " +
            "This may indicate an incomplete partition key range resolution during query setup.");
    }
    const pkRange = rangeMapping.partitionKeyRange;
    // Create simplified range assuming min is inclusive and max is exclusive
    const simplifiedRange = {
        min: pkRange.minInclusive,
        max: pkRange.maxExclusive,
    };
    return {
        queryRange: simplifiedRange,
        continuationToken: rangeMapping.continuationToken,
    };
}
/**
 * Converts an array of QueryRangeMapping to an array of QueryRangeWithContinuationToken
 * @param rangeMappings - Array of QueryRangeMapping to convert
 * @returns Array of QueryRangeWithContinuationToken with simplified boundaries and continuation tokens
 * @hidden
 */
function convertRangeMappingsToQueryRangesWithTokens(rangeMappings) {
    return rangeMappings.map((mapping) => convertRangeMappingToQueryRange(mapping));
}
/**
 * Converts a SimplifiedQueryRange back to a QueryRange for internal use
 * @param simplifiedRange - The simplified range to convert
 * @returns QueryRange with standard assumptions (min inclusive, max exclusive)
 * @hidden
 */
function convertSimplifiedRangeToQueryRange(simplifiedRange) {
    return new QueryRange_js_1.QueryRange(simplifiedRange.min, simplifiedRange.max, true, // minInclusive = true (assumption)
    false);
}
//# sourceMappingURL=CompositeQueryContinuationToken.js.map